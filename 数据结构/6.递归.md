本笔记内容涵盖了递归的基本概念、设计方法、执行原理，以及如何将递归算法转化为非递归算法。

---

## 一、 递归 (Recursion)

1. 递归的定义 

> 递归是在定义一个过程或函数的**同时又出现了对自身的调用**的一种方法。 

递归可以分为两种类型：

- **直接递归 (Direct Recursion)**: 一个函数在其函数体内直接调用自己。 
    
- **间接递归 (Indirect Recursion)**: 一个函数通过一系列的中间调用，最终间接地调用了自己。 
    

递归是程序设计中一种非常强大的工具。 

- **优点**: 采用递归编写的程序通常**代码简洁、逻辑清晰**，符合结构化程序设计的思想，可读性好。 
    
- **挑战**: 理解编译器如何处理递归调用，以及在不支持递归的语言中如何实现类似逻辑。 
    

### 2. 递归的构成要素

一个有效的递归算法必须包含两个核心要素，以阶乘函数为例进行说明。

#### 示例：求n的阶乘

数学定义如下：

$n!=n*(n−1)!,n>0,n=0$ ​

这里的递归出口（终止条件）是 0!=1。 

根据这个定义，递归算法包含：

1. **递归子式 (Recursive Step)**: 将问题分解为更小规模的相同问题。例如，$fac(n) = n * fac(n-1)$,这是函数调用自身的部分。 
    
2. **基值判断 (Base Case)**: 也称为递归出口，是递归终止的条件，它能保证递归不会无限进行下去。例如，`if (n == 0 || n == 1)` 就是基值判断，满足该条件后将执行最终计算 `p=1`。 
    

#### C++ 实现阶乘

```CPP
long fac(int n) {
    long p;
    if (n == 0 || n == 1) { // 基值判断
        p = 1;
    } else {
        p = n * fac(n-1); // 递归子式
    }
    return p;
}
```



### 3. 递归的执行过程：递归工作栈

为了保证递归函数能够正确执行，系统内部需要使用一个“**递归工作栈**”（Recursion Stack）来管理函数调用。 

- **工作记录 (Activation Record)**: 每当进入一层递归调用，系统就会创建一个新的“工作记录”并压入栈顶。 这个记录包含了当前调用层级所需的所有信息，如：
    
    - 所有**实参**
        
    - 所有**局部变量**
        
    - 上一层调用的**返回地址** 
        
- **活动记录 (Active Record)**: 位于栈顶的工作记录被称为“活动记录”，代表当前正在执行的函数环境。 
    
- **调用与返回**:
    
    - 进入下一层递归，相当于将一个新的工作记录压栈。 
        
    - 退出当前层递归，相当于从栈顶弹出一个工作记录，并将控制权返回给上一层（新的栈顶）。 
        

#### 示例：`fac(5)`的递归层次

假设主函数是第0层，调用`fac(5)`是进入第1层，以此类推。 

- **分解过程 (Diving)**:
    
    - `fac(5)` 调用 `fac(4)`
        
    - `fac(4)` 调用 `fac(3)`
        
    - `fac(3)` 调用 `fac(2)`
        
    - `fac(2)` 调用 `fac(1)` -> 命中基值，返回1。 
        
- **求值过程 (Returning)**:
    
    - `fac(1)` 返回 `1` 
        
    - `fac(2)` 接收到1，计算 `2 * 1`，返回 `2` 
        
    - `fac(3)` 接收到2，计算 `3 * 2`，返回 `6` 
        
    - `fac(4)` 接收到6，计算 `4 * 6`，返回 `24` 
        
    - `fac(5)` 接收到24，计算 `5 * 24`，返回 `120` 
        

整个递归过程是先层层深入（分解），遇到递归出口后再层层返回（求值）。 

### 4. 何时使用递归

在以下三种情况下，使用递归通常是自然且高效的选择： 

1. **定义是递归的**: 许多数学公式或数列本身就是用递归方式定义的。 
    
    - **例子：斐波那契数列 (Fibonacci Sequence)** 
        
        Fib(n)={n,Fib(n−1)+Fib(n−2),​n=0,1n>1​
        
        
        
2. **数据结构是递归的**: 某些数据结构的定义具有递归特性。 
    
    - 例子：链表 (Linked List)
        
        一个链表可以被定义为：一个数据节点，加上指向另一个链表（剩余部分）的指针。 
        
        ```cpp
        // 求不带头结点的单链表所有data域之和
        int Sum(LinkList *head) {
            if (head == NULL) { // 递归出口：空链表和为0
                return 0;
            } else { // 递归体：当前节点值 + 剩余链表之和
                return (head->data + Sum(head->next));
            }
        }
        ```
        
        
        
3. **问题的求解方法是递归的**: 问题的解决方案可以自然地分解为结构相同的子问题。 33 这通常与“**分而治之**” (Divide and Conquer) 的思想紧密相关。
    
    - **例子：汉诺塔 (Hanoi Tower) 问题** 
        
        - **问题描述**: 将A柱上的n个盘子，借助B柱，全部移动到C柱。
            
        - **规则**:
            
            1. 每次只能移动一个盘子。 
                
            2. 大盘子不能放在小盘子上面。 
                
        - **递归解法 (分治策略)**: 要将 `n` 个盘子从 `a` 移动到 `c`：
            
            1. **`Hanoi(n-1, a, c, b)`**: 将 `n-1` 个较小的盘子从 `a` 移动到 `b`（借助 `c`）。 
                
            2. **`Move(n, a, c)`**: 将第 `n` 个（最大的）盘子从 `a` 直接移动到 `c`。 
                
            3. **`Hanoi(n-1, b, a, c)`**: 将 `n-1` 个较小的盘子从 `b` 移动到 `c`（借助 `a`）。 
                
        - **移动次数**: 移动n个盘子所需的次数为 T(n)。
            
            - T(n)=2T(n−1)+1 
                
            - 通过展开可得：
                
                $T(n)=2^n−1$ 
                

---

## 二、 递归算法的设计

设计递归算法的核心是建立一个正确的**递归模型**，然后将其转换为编程语言。 

### 1. 递归模型

递归模型是对递归算法的抽象，由**递归出口**和**递归体**两部分组成。 

- **递归出口 (Base Case)**: 确定递归何时终止。 
    
- **递归体 (Recursive Body)**: 定义“大问题”与“小问题”之间的递推关系。 
    

### 2. 递归设计步骤

设计过程类似于数学归纳法： 

1. **分析问题**：对原问题 f(s)，假设一个规模更小的子问题 f(s′)。 
    
2. **建立关系**: 假设 f(s′) 是可解的，在此基础上推导出 f(s) 的解，即建立 f(s) 和 f(s′) 的关系。 
    
3. **确定出口**: 找到一个或多个可以直接求解的特定情况（例如 f(0) 或 f(1)），作为递归的终止条件。 
    

#### 示例：递归求解数组中的最小值

**问题**: 求实数数组 `A[0..n-1]` 中的最小值。*(此处 n 和 0 均为数组角标)* 

1. **定义与假设**: 定义 `f(A, i)` 为求解数组 `A[0..i]` 中最小值。假设我们已经能解出 `f(A, i-1)`。 
    
2. **建立关系**: `A[0..i]` 的最小值，等于 `A[0..i-1]` 的最小值与 `A[i]` 之间较小的那一个。即 $f(A,i)=min(f(A,i−1),A[i])$。 
    
3. **确定出口**: 当 `i=0` 时，`A[0..0]` 的最小值显然就是 `A[0]`。即$f(A,0)=A[0]$。 
    

递归模型: $f(A,i)=min(f(A,i−1),A[i])$ 



---

## 三、 递归与非递归的转化

### 1. 为何需要转化

- **优点**: 递归代码清晰、易于理解。 
    
- **缺点**: 递归调用会带来额外的时间和空间开销（函数调用、栈空间分配等）。对于深度递归，还可能导致“栈溢出”（Stack Overflow）。 
    

因此，在追求高性能和节省空间的场景下，需要将递归算法转化为非递归（迭代）算法。 

### 2. 转化的基本方法

1. **使用循环结构**: 对于某些简单的递归（特别是尾递归），可以直接分析其求值过程，用循环来代替。（在递归时存在重复问题） 
    
    - **示例：非递归求斐波那契数列**
        
        ```cpp
        int Fib(int n) {
            if (n == 1 || n == 0) return n;
            int f1 = 1, f2 = 1, f3;
            for (int i = 3; i <= n; i++) {
                f3 = f1 + f2;
                f1 = f2;
                f2 = f3;
            }
            return f3;
        }
        ```
        
        
        
2. **使用栈模拟系统调用**: 任何递归都可以用栈来模拟实现，因为递归的本质就是一种“后进先出”的栈式结构。 
    
    - **思路**: 自己创建一个栈，用来保存递归调用中需要保留的中间状态（如参数、局部变量）。通过循环和栈操作（压栈、弹栈）来模拟递归的深入和返回过程。 
        
    - 示例：用栈模拟阶乘计算可以设计一个栈，每个元素包含需要计算的`n` 值以及一个状态标记 `tag`（标识该值是否已计算出结果）。 
        
        - **分解**: 当栈顶元素的阶乘值未计算时，如果它不是基值，就将 `n-1` 的计算任务压入栈中。 
            
        - **求值**: 当栈顶元素的阶乘值已计算出，或者命中了基值，就将其结果用于计算下一层（次栈顶）的结果，并弹出栈顶元素。 
```cpp
const int MAXSIZE = 1000;          // 栈最大深度

/* 1. 栈结点：保存 n、fac(n) 以及是否已求出标记 */
struct SqStack {
    int vn;   // 当前 n
    int vf;   // 当前 fac(n) 值
    int tag;  // 1: 尚未求出 vf   0: 已求出 vf
};

SqStack St[MAXSIZE];               // 手工栈
int top = -1;                      // 栈顶指针

/* 2. 非递归阶乘算法 */
int fac(int n)
{
    /* 2.1 初值进栈： (n, *, 1) */
    St[++top].vn = n;
    St[top].vf   = 0;   // 占位，无意义
    St[top].tag  = 1;   // 尚未求出

    while (top >= 0) {  // 栈不空
        if (St[top].tag == 1) {           // 尚未求出 vf
            if (St[top].vn == 0) {        // (1) 递归出口
                St[top].vf  = 1;          // fac(0)=1
                St[top].tag = 0;          // 标记已求出
            } else {                      // (2) 递归体
                /* 压栈 (n-1, *, 1) */
                St[++top].vn = St[top - 1].vn - 1;
                St[top].vf   = 0;
                St[top].tag  = 1;
            }
        } else if (St[top].tag == 0) {    // 已求出 vf
            /* 由次栈顶元素分解而来，回代计算 */
            St[top - 1].vf  = St[top - 1].vn * St[top].vf;
            St[top - 1].tag = 0;
            top--;                        // 退栈
        }

        /* 只剩一个已求值的元素 → 结束 */
        if (top == 0 && St[top].tag == 0)
            break;
    }
    return St[top].vf;   // 栈底即最终结果
}
```

---

### 本讲小结

- **重点**:
    
    - 理解递归的核心概念：基值判断和递归子式。 
        
    - 掌握递归算法的设计方法，能够构建递归模型。 
        
- **难点**:
    
    - 将递归算法转化为等价的非递归算法，尤其是使用栈来模拟递归的执行过程。 