## 一、 最短路径问题简介

### 1. 问题提出

在日常生活中，我们经常需要寻找最优路径，例如在地图上找两个城市之间的最短车程或最低费用的路线。这类问题可以被抽象为图论中的最短路径问题。

在一个带权有向图中：

- **顶点 (Vertex)**：代表地点，如城市、交叉路口等。
    
- **边 (Edge)**：代表两个顶点之间的连接，如公路、航线等。
    
- **权 (Weight)**：表示通过某条边的成本，例如距离、时间或费用。
    

> **最短路径** 的定义是：从一个顶点（源点）出发，到达另一个顶点（终点）的所有可能路径中，构成路径的各边权重之和最小的那一条路径。

### 2. 无权图与带权图的最短路径

- **非网图 (Unweighted Graph)**：在这种图中，所有边的权重都默认为1。最短路径指连接两个顶点经过的 **边数最少** 的路径。
    
- **网图 (Weighted Graph)**：在这种图中，每条边都有具体的权值。最短路径指连接两个顶点经过的 **边上权值之和最小** 的路径。
    

## 二、 单源最短路径 - 迪杰斯特拉 (Dijkstra) 算法

Dijkstra算法用于解决 **单源点最短路径问题**，即给定一个源点，计算出它到图中所有其他顶点的最短路径。 该算法由迪杰斯特拉（Dijkstra）提出，其特点是按路径长度递增的次序来生成最短路径。

> **注意**：标准的Dijkstra算法不适用于带有负权边的图。

### 1. 核心思想

算法的基本思想是 **贪心策略**。它将图中的所有顶点分为两个集合：

1. **集合 U**：已经找到从源点出发的最短路径的顶点集合。
    
2. **集合 V-U**：尚未找到从源点出发的最短路径的顶点集合。
    

算法的执行过程如下：

1. **初始化**：集合 `U` 中只包含源点 `$v$`。对于 `$v$` 能直接到达的顶点 `$v_i$`，其最短路径初值为边的权重 `$arcs[v][v_i]$`；对于不能直接到达的顶点，路径长度为无穷大 `$\infty$`。
    
2. 迭代：重复以下步骤 $n-1$ 次（$n$ 为顶点总数）：
    
    a. 从集合 V-U 中，选择一个距离源点 $v$ 最近的顶点 $v_j$（即 $Dist[j]$ 最小）。
    
    b. 将 $v_j$ 加入集合 U 中。
    
    c. 松弛操作：更新 $v_j$ 的所有邻接顶点 $v_k$ (其中$v_k$属于V-U) 的最短路径。如果经过 $v_j$ 到达 $v_k$ 的路径比已知的 $v$ 到 $v_k$ 的路径更短，则更新 $Dist[k]$ 的值。其判断条件为：
    
    $$Dist[j] + \text{arcs}[j][k] < Dist[k]
    
    $$
    

### 2. 数据结构与实现

- **图存储**：带权的邻接矩阵 `G.matrix`。
    
- `dist[n]` **数组**：存储源点到各顶点 `$i$` 的当前最短路径长度。
    
- `path[n]` **数组**：记录最短路径上，顶点 `$i$` 的前一个顶点是谁，用于回溯输出完整路径。
    
- `visited[n]` **布尔数组**：标记顶点是否已在集合U中（即是否已找到最短路径）。
    

**C语言核心逻辑伪代码**

```c
// v0 是源点
void Dijkstra(Graph g, int v0) {
    // 1. 初始化 dist[], path[], visited[]
    for (int i = 0; i < g.n; i++) {
        dist[i] = g.matrix[v0][i];
        visited[i] = false;
        if (dist[i] < infinity) {
            path[i] = v0;
        } else {
            path[i] = -1;
        }
    }
    visited[v0] = true;
    dist[v0] = 0;

    // 2. 主循环 n-1 次
    for (int i = 1; i < g.n; i++) {
        // 2.1 寻找V-U中dist最小的顶点u
        int min = infinity;
        int u = -1;
        for (int j = 0; j < g.n; j++) {
            if (!visited[j] && dist[j] < min) {
                min = dist[j];
                u = j;
            }
        }
        
        // 2.2 将u并入U
        if (u != -1) {
            visited[u] = true;
        }
        
        // 2.3 更新u的邻接点的dist和path
        for (int k = 0; k < g.n; k++) {
            if (!visited[k] && g.matrix[u][k] < infinity) {
                if (dist[u] + g.matrix[u][k] < dist[k]) {
                    dist[k] = dist[u] + g.matrix[u][k];
                    path[k] = u;
                }
            }
        }
    }
}
```

## 三、 所有顶点对最短路径 - 弗洛伊德 (Floyd) 算法

Floyd算法用于解决 **所有顶点对之间的最短路径问题**。 与Dijkstra算法需要以每个顶点为源点重复执行n次不同，Floyd算法通过一次计算就能找出所有顶点对的最短路径。 它的时间复杂度也是 `$O(n^3)$`，但代码形式更简洁。

### 1. 核心思想

Floyd算法的核心是 **动态规划**。它通过 `$n$` 次迭代，逐步求得更优的路径。其思想是：对于任意一对顶点 `($v_i$, $v_j$)`，它们之间的最短路径，要么是直接连接的弧，要么是经过了某个中间顶点 `$v_k$`。

算法允许路径经过的中间顶点范围从空集逐步扩大到全集 `{$v_0, v_1, ..., v_{n-1}$}`。

### 2. 核心迭代公式

设 `$dist_k[i][j]$` 为从顶点 `$i$` 到 `$j$`，且路径上所有中间顶点的序号都不大于 `$k$` 的最短路径长度。

- **初始状态** (`$k=-1$`): `$dist_{-1}[i][j]$` 就是邻接矩阵中 `$arc[i][j]$` 的值。
    
- **迭代关系**:
    
    $$dist_k[i][j] = \min(dist_{k-1}[i][j], \quad dist_{k-1}[i][k] + dist_{k-1}[k][j])
    
    $$这个公式的含义是：从 `$i$`到 `$j$`，允许中间顶点序号最大为 `$k$` 的最短路径，要么就是原来不允许经过 `$k$` 的那条路，要么就是经过 `$k$` 的那条路。在实际实现中，`$k$` 这一维度可以被优化掉，直接在二维数组上更新。
    

### 3. 数据结构与实现

- `dist[n][n]` **二维数组**：`dist[i][j]` 存储从顶点 `$i$` 到 `$j$` 的最短路径长度。
    
- `path[n][n]` **二维数组**：记录 `$i$` 到 `$j$` 的最短路径所经过的中间顶点，用于路径还原。
    

**C++核心逻辑伪代码**

```c
// G是邻接矩阵表示的图
void Floyd(Graph G) {
    // 1. 初始化 dist[][] 和 path[][] 矩阵
    for (int i = 0; i < G.vertexNum; i++) {
        for (int j = 0; j < G.vertexNum; j++) {
            dist[i][j] = G.arc[i][j];
            // path 初始化逻辑...
        }
    }

    // 2. 三层循环，核心迭代
    // k 是中间顶点
    for (int k = 0; k < G.vertexNum; k++) {
        // i 是起始顶点
        for (int i = 0; i < G.vertexNum; i++) {
            // j 是终止顶点
            for (int j = 0; j < G.vertexNum; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    // 更新 path 矩阵...
                }
            }
        }
    }
}
```

由于是三层嵌套循环，因此时间复杂度是 `$O(n^3)$`。

## 四、 本讲小结

本讲主要介绍了两种计算最短路径的经典算法：

1. **Dijkstra算法**：采用贪心策略，用于解决 **单源最短路径** 问题，时间复杂度为 `$O(n^2)$` (用邻接矩阵) 或 `$O((m+n)\log n)$` (用优先队列优化)。不适用于有负权边的图。
    
2. **Floyd算法**：基于动态规划，用于解决 **所有顶点对之间的最短路径** 问题，时间复杂度为 `$O(n^3)$`。可以处理带负权边的图，但不能处理包含负权回路的图。