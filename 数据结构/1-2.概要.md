## **第一部分：线性数据结构——两种“排队”方式**

### **1.1 顺序表 `std::vector`：连续的座位**

- **核心概念：** 元素在内存中是**连续存储**的，就像电影院里一排连续的座位。

- **优点：**
  
  - **随机访问快 (O(1))**：可以通过下标直接定位到任何元素，速度极快。

- **缺点：**
  
  - **插入和删除慢 (O(n))**：在中间插入或删除一个元素，需要移动之后的所有元素。

- **适用场景：** 数据**读多写少**，需要频繁通过索引快速访问元素的场景。

```Cpp
#include <vector>
#include <iostream>

void vector_example() {
    std::vector<int> vec = {10, 20, 40};
    // 优点：快速访问
    std::cout << "Index 1 is: " << vec[1] << std::endl; // 输出 20

    // 缺点：中间插入
    vec.insert(vec.begin() + 2, 30); // 在 20 和 40 之间插入 30，40需要向后挪
}
```

### **1.2 单链表 (Singly Linked List)：手拉手的朋友**

- **核心概念：** 由一系列**节点 (Node)** 组成，每个节点包含**数据 (data)** 和一个指向**下一个节点的指针 (next)**。节点在内存中是**非连续存储**的。

- **优点：**
  
  - **插入和删除快 (O(1))**：只需要修改相邻节点的指针指向即可。

- **缺点：**
  
  - **随机访问慢 (O(n))**：想访问第 `i` 个元素，必须从头节点开始遍历 `i` 次。

- **适用场景：** 数据**写多读少**，需要频繁地插入和删除元素的场景。

```Cpp
// 单链表节点的标准定义
struct Node {
    int data;       // 节点存储的数据
    Node* next;     // 指向下一个节点的指针

    // 构造函数
    Node(int val) : data(val), next(nullptr) {}
};
```

---

## **第二部分：单链表的核心操作与技巧 (C++)**

### **2.1 虚拟头结点 (Dummy Head)**

这是一个编程技巧，通过创建一个不存储任何有效数据的“哨兵”头结点，可以**统一所有位置（包括头部）的插入和删除逻辑**，让代码更简洁，避免对头节点的特殊判断。

### **2.2 高效插入：头插法 vs. 尾插法**

- **头插法：** 永远在链表的头部（`dummyHead`之后）插入新节点。
  
  - **特点：** 最终链表的顺序与插入顺序**相反**。
  
  - **代码示例：**

        ```cpp
        void insertAtHead(Node* dummyHead, int val) {
            Node* newNode = new Node(val);
            newNode->next = dummyHead->next;
            dummyHead->next = newNode;
        }
        ```

- **尾插法：** 永远在链表的末尾添加新节点。
  
  - **技巧：** 为了避免每次都从头遍历到尾部（O(n)），需要额外维护一个 `tail` 指针，让它始终指向当前的尾节点，从而实现 O(1) 的插入。
  
  - **特点：** 最终链表的顺序与插入顺序**相同**。
  
  - **代码示例：**

        ```cpp
        void insertAtTail(Node*& tail, int val) { // 注意 tail 是引用
            Node* newNode = new Node(val);
            tail->next = newNode;
            tail = newNode; // 更新 tail 指针
        }
        ```

### **2.3 查找与删除**

- **查找 (Search)：** 从头节点开始，顺着 `next` 指针逐一遍历比较即可。

- **删除 (Deletion)：** 这是单链表最核心的操作之一。
  
  - **核心逻辑：** 单链表是“单行道”，无法回头。要删除一个节点，**必须先找到它的前一个节点 `prev`**。
  
  - **步骤：**
    
    1. 从头遍历找到 `prev` 节点。
    
    2. 用一个临时指针 `nodeToDelete` 保存要删除的节点 (`prev->next`)。
    
    3. 让 `prev` 的指针“跳过”要删除的节点：`prev->next = nodeToDelete->next`。
    
    4. 释放被删除节点的内存：`delete nodeToDelete;`。

---

## **第三部分：单链表的经典算法**

### **3.1 合并两个有序链表**

- **核心思路（双指针法）：** 像拉拉链一样。用两个指针 `p1`, `p2` 分别指向两个链表的头，比较 `p1` 和 `p2` 的值，将较小的节点连接到新链表上，然后将该指针后移。重复此过程，直到一个链表为空。最后，将另一个链表剩余的部分直接全部连接到新链表的末尾。
  
  ```cpp
  Node* mergeTwoLists(Node* list1, Node* list2) {
    Node* dummyHead = new Node(0);
    Node* current = dummyHead;
    while (list1 != nullptr && list2 != nullptr) {
        if (list1->data <= list2->data) {
            current->next = list1;
            list1 = list1->next;
            } else {
               current->next = list2;
                   list2 = list2->next;
        }
        current = current->next;
       }
    // 连接剩余部分
    current->next = (list1 != nullptr) ? list1 : list2;
    Node* result = dummyHead->next;
    delete dummyHead;
    return result;
  }
  ```

### **3.2 求两个链表的差集 (A - B)**

- **核心思路（空间换时间）：** 利用 `unordered_set` 的 O(1) 快速查找特性。
  
  1. 遍历 `listB`，将其所有元素存入一个 `unordered_set`。
  
  2. 遍历 `listA`，对于 `listA` 中的每个元素，去 `unordered_set` 中检查是否存在。
  
  3. 如果不存在，则该元素属于差集，将其加入到结果链表中。

- **效率：** 此方法时间复杂度为 O(m+n)，远优于嵌套循环的 O(m*n)。

---

## **第四部分：高级应用实例——LRU 缓存算法**

- **核心思想：** 淘汰最久未被使用的数据 (Least Recently Used)。

- **最佳数据结构组合：哈希表 + 双向链表**
  
  - `std::unordered_map<key, Node*>`：提供 O(1) 的查找能力，通过 `key` 瞬间定位到链表中的节点。
  
  - **双向链表：** 维护数据的“新鲜度”。越靠近头部，代表越新被使用。因为是双向的，所以任意节点的移动和删除操作也是 O(1)，完美解决了单链表删除慢的问题。

- **操作逻辑：**
  
  - `get(key)`：命中时，将对应节点**移动到链表头部**。
  
  - `put(key, value)`：
    
    - 若 `key` 存在，更新 `value`，并将节点**移动到链表头部**。
    
    - 若 `key` 不存在，创建新节点并**加入到链表头部**。如果此时超出容量，则**删除链表尾部**的节点（它就是最久未使用的），并同时从哈希表中移除。

---

## **第五部分：C++ STL 核心关联容器详解**

### **5.1 底层实现两大派系**

1. **红黑树 (自平衡二叉搜索树):**
   
   - **用于:** `std::set`, `std::map`
   
   - **工作原理:** 保证元素**有序**。通过复杂的“旋转”和“重新着色”操作，时刻维持树的平衡，确保增、删、查操作性能稳定在 **O(log n)**。

2. **哈希表:**
   
   - **用于:** `std::unordered_set`, `std::unordered_map`
   
   - **工作原理:** 元素**无序**。通过**哈希函数**将任意 `key` 转换为数组下标来实现快速定位。用**拉链法**（在冲突位置挂一个链表）解决哈希冲突。平均性能为 **O(1)**。

### **5.2 容器速查表**

| 容器                       | 存储内容           | 是否有序  | 底层实现 | 平均查找性能   | 主要用途                   |
| ------------------------ | -------------- | ----- | ---- | -------- | ---------------------- |
| **`std::set`**           | 唯一的键(Key)      | **是** | 红黑树  | O(logn)  | 存储需要自动排序的唯一元素          |
| **`std::unordered_set`** | 唯一的键(Key)      | 否     | 哈希表  | **O(1)** | 只关心快速存取和去重，不关心顺序       |
| **`std::map`**           | 键值对(Key-Value) | **是** | 红黑树  | O(log n) | 存储需要按键排序的键值对数据         |
| **`std::unordered_map`** | 键值对(Key-Value) | 否     | 哈希表  | **O(1)** | 快速建立`key`和`value`的映射关系 |
