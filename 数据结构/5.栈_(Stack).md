本讲将深入探讨一种重要的数据结构——栈。我们将从栈的定义、基本操作、两种主要的存储结构（顺序栈和链栈）及其代码实现，最后到栈在实际问题中的应用，如数制转换、括号匹配和迷宫求解。

## 一、栈的定义与基本概念

### 1\. 定义

栈（Stack）是一种特殊的线性表，其特殊之处在于**只允许在线性表的一端进行插入和删除操作** 。

  * **栈顶 (Top)**：允许进行插入和删除操作的一端 。
  * **栈底 (Bottom)**：与栈顶相对的另一端，是固定不动的 。
  * **进栈 (Push)**：向栈中插入元素的过程 。
  * **退栈 (Pop)**：从栈中删除元素的过程 。
### 2\. 特点

栈的最显著特点是 **后进先出 (Last-In, First-Out, LIFO)** 。这意味着最后进入栈的元素将最先被移出。

### 3\. 栈和普通线性表的区别

栈本身是一个线性表，但它的操作受到了限制。普通线性表（如数组、链表）允许在任何位置进行插入和删除操作，而栈只允许在栈顶进行。这种操作上的限制是栈和普通线性表最主要的区别 。

### 4\. 基本操作

以下是栈的几个核心基本操作：

  * `InitStack(S)`: 初始化操作，将一个已声明的栈变为空栈 。
  * `IsEmpty(S)`: 判空操作，检查栈是否为空。若为空，返回 `true`，否则返回 `false` 。
  * `Push(S, x)`: 入栈操作，将元素 `x` 插入到栈 S，使其成为新的栈顶元素 。
  * `Pop(S, &x)`: 出栈操作，删除 S 的栈顶元素，并用 `x` 返回该元素的值 。
  * `GetTop(S, &x)`: 取栈顶元素操作，用 `x` 返回栈顶元素的值，但不删除该元素 。
  * `ClearStack(S)`: 清空栈 。

## 二、栈的存储结构与实现

栈可以采用两种主要的存储结构：顺序存储和链式存储。

### 1\. 顺序栈 (Sequential Stack)

顺序栈是利用一组地址连续的存储单元（通常是数组）来依次存放从栈底到栈顶的数据元素，同时附设一个指针 `top` 指示栈顶元素的位置 。

#### a. 定义

通常用一个结构体来封装数组和栈顶指针：

```c
typedef struct {
    StackElementType elem[Stack_Size]; // 存放栈元素的数组 
    int top;                           // 存放栈顶元素的下标 
} SeqStack;
```

  * **栈满**：当 `top == Stack_Size - 1` 时，栈为满 。
  * **栈空**：当 `top == -1` 时，栈为空 。

#### b. 基本操作实现 (C 语言)

  * **初始化 `InitStack`**

    ```c
    void InitStack(SeqStack *S) {
        S->top = -1; // 将top指针设为-1表示空栈 
    }
    ```

  * **判空 `IsEmpty`**

    ```c
    int IsEmpty(SeqStack *S) {
        return (S->top == -1 ? TRUE : FALSE); // 检查top是否为-1 
    }
    ```

  * **入栈 `Push`**

    ```c
    int Push(SeqStack *S, StackElementType x) {
        if (S->top == Stack_Size - 1) return(FALSE); // 栈满，无法入栈 
        S->top++; // 栈顶指针上移 
        S->elem[S->top] = x; // 存入元素 
        return(TRUE);
    }
    ```

  * **出栈 `Pop`**

    ```c
    int Pop(SeqStack *S, StackElementType *x) {
        if (S->top == -1) return(FALSE); // 栈空，无法出栈 
        *x = S->elem[S->top]; // 取出栈顶元素 
        S->top--; // 栈顶指针下移 
        return(TRUE);
    }
    ```

  * **取栈顶元素 `GetTop`**

    ```c
    int GetTop(SeqStack *S, StackElementType *x) {
        if (S->top == -1) return(FALSE); // 栈空 
        *x = S->elem[S->top]; // 取出栈顶元素，但指针不变 
        return(TRUE);
    }
    ```

> **复杂度分析**: 对于顺序栈，`Push`、`Pop`、`GetTop` 和 `IsEmpty` 操作都只涉及对栈顶指针的访问和修改，因此它们的时间复杂度均为 $O(1)$。

### 2\. 链栈 (Linked Stack)

链栈是采用链式存储结构的栈。其优点是空间可以根据需要动态扩充，不存在顺序栈的栈满问题 。

#### a. 定义与特点

  * 通常将**链表的头部作为栈顶**，这样插入和删除操作都无需遍历链表，时间复杂度为 $O(1)$ 。
  * 链栈通常带有一个头结点，栈顶指针 `top` 指向头结点。当 `top->next == NULL` 时，表示栈为空 。
  * 使用完毕后，需要手动释放所有节点的内存空间 。

```c
typedef struct node {
    StackElementType data;
    struct node *next;
} LinkStackNode;
typedef LinkStackNode *LinkStack; 
```


#### b. 基本操作实现 (C 语言)

  * **入栈 `Push`** (相当于在链表头部插入新节点)

    ```c
    int Push(LinkStack top, StackElementType x) {
        LinkStackNode *temp;
        temp = (LinkStackNode *)malloc(sizeof(LinkStackNode)); // 申请新节点空间 
        if (temp == NULL) return(FALSE); // 空间申请失败 
        temp->data = x;
        temp->next = top->next; // 新节点的next指向原栈顶元素 
        top->next = temp; // 头结点的next指向新节点，使其成为新栈顶 
        return(TRUE);
    }
    ```

  * **出栈 `Pop`** (相当于删除链表头部的第一个元素节点)

    ```c
    int Pop(LinkStack top, StackElementType *x) {
        LinkStackNode *temp;
        temp = top->next;
        if (temp == NULL) return(FALSE); // 栈空 
        *x = temp->data; // 取出数据 
        top->next = temp->next; // 头结点指向下一个节点 
        free(temp); // 释放原栈顶节点的空间 
        return(TRUE);
    }
    ```

> **复杂度分析**: 对于链栈，`Push` 和 `Pop` 操作都只涉及头结点的修改，时间复杂度同样为 $O(1)$。

## 三、栈的应用

栈的 LIFO 特性使其在解决许多计算机科学问题时非常有用。

### 1\. 数制转换

**a. 原理**
将一个十进制数 $N$ 转换为 $d$ 进制数，可以反复地对 $N$ 进行除 $d$ 取余的运算。其原理是：
$$N = (N \text{ div } d) \times d + (N \text{ mod } d)$$
其中，`div` 是整除，`mod` 是取余。
我们发现，计算过程中**先得到的余数反而在转换结果的低位，后得到的余数在转换结果的高位**。这个顺序正好与栈的“后进先出”特性吻合 。
例如，(1348)₁₀ 转换为八进制：

| N| N div 8 | N mod 8 |
|--|--|--|
| 1348 | 168 | 4 |
| 168  | 21  | 0 |
| 21   | 2   | 5 |
| 2    | 0   | 2 |
将余数依次入栈（4, 0, 5, 2），然后依次出栈，得到 **2504**，即 (2504)₈ 。

**b. 算法实现**

```c
void conversion(int N, int d) {
    Stack S;
    int x;
    InitStack(&S);
    if (N == 0) { // 思考：处理输入为0的特殊情况 
        cout << "0";
        return;
    }
    while (N != 0) {
        Push(&S, N % d); // 余数入栈 
        N = N / d;       // 更新N为商 
    }
    while (!isEmpty(S)) {
        Pop(&S, &x);     // 依次出栈并输出 
        cout << x;
    }
}
```

> **补充思考**：若要转换为十六进制，当余数大于 9 时，需要将其转换为 'A' 到 'F' 的字符。可以在出栈时进行判断和转换 。

```cpp
std::string decToHex(unsigned int n) {
    if (n == 0) return "0";

    std::stack<char> st;              // 用栈保存每一位的 16 进制字符
    const char digits[] = "0123456789ABCDEF";  //也可利用ASCII码强制转换
    while (n > 0) {
        st.push(digits[n % 16]);      // 取余得到最低 4 位对应的字符
        n /= 16;                      // 去掉最低 4 位
    }

    std::string hex;
    while (!st.empty()) {             // 后进先出，依次弹出高位到低位
        hex += st.top();
        st.pop();
    }
    return hex;
}
```

### 2\. 括号匹配

**a. 原理**
检查一个表达式中的括号（如 `()`, `[]`, `{}`）是否正确配对。
算法思想是：

1.  从左到右扫描表达式字符串 。
2.  遇到**左括号** (`(`, `[`, `{`)，将其**入栈** 。
3.  遇到**右括号** (`)`, `]`, `}`), 检查栈顶元素：
      * 若栈为空，说明没有左括号与之匹配，则不匹配 。
      * 若栈不为空，取出栈顶的左括号。如果与当前右括号是同一类型（如 `(` 与 `)`），则匹配成功，将栈顶元素**出栈** 。
      * 如果类型不匹配，则整个表达式不匹配 。
4.  整个表达式扫描结束后，如果**栈为空**，则所有括号都已正确匹配 。如果栈中仍有元素，说明有未匹配的左括号 。

**b. 算法实现**

```c
bool Match(char *s) {
    Stack tmpS;
    char tmpCh;
    InitStack(&tmpS);

    for (int i = 0; i < strlen(s); i++) {
        // 如果是左括号，入栈
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') {
            Push(&tmpS, s[i]); 
        }
        // 如果是右括号 ')'
        else if (s[i] == ')') {
            if (IsEmpty(tmpS)) return false; // 栈空，不匹配 
            GetTop(tmpS, &tmpCh);
            if (tmpCh == '(') Pop(&tmpS, &tmpCh); // 匹配，出栈 
            else return false; // 不匹配 
        }
        // ... 此处省略对 ']' 和 '}' 的类似判断逻辑...
    }

    // 循环结束后，检查栈是否为空
    if (IsEmpty(tmpS)) return true; // 栈空，完全匹配 
    else return false; // 栈不空，有未匹配的左括号 
}
```

### 3\. 迷宫求解 (回溯法)

**a. 问题描述与思想**
在一个 $m \times n$ 的迷宫中，给定入口和出口，寻找一条从入口到出口的路径 。
**回溯法** 是解决此类问题的经典方法：从入口出发，沿着一个方向探索，如果能走通就继续；如果遇到障碍或死胡同，就退回到上一个路口，选择另一个方向继续探索 。这个“退回”的过程，完美地契合了栈的“后进先出”特性。

**b. 算法思路**

1.  使用一个栈来保存已经走过的路径上的坐标点。
2.  将入口坐标压入栈中 。
3.  当栈不为空时，循环执行以下操作：
      * 获取栈顶坐标作为当前位置，但不出栈。
      * 如果当前位置是出口，则说明找到路径，算法结束 。
      * 按照预设的方向顺序（如：东、南、西、北）查找当前位置的下一个可通且未走过的相邻方块 。
      * **如果找到**：将该新方块的坐标压入栈中，并将其标记为“已走过”，然后继续循环 。
      * **如果找不到**（即当前位置的四个方向都无法前进）：说明当前位置是死胡同，需要回溯。将栈顶元素**出栈**（即从路径中移除当前位置），返回到上一个位置去尝试其他方向 。
4.  如果循环结束时栈为空，说明所有可能的路径都已尝试过但无法到达出口，迷宫无解 。

## 四、本讲小结

  * **掌握核心操作**：能够熟练地用代码实现栈的初始化、入栈和出栈操作 。
  * **理解本质区别**：能够清晰地说明栈作为一种受限的线性表，与普通线性表（如单链表）在操作上的根本区别 。
  * **学以致用**：能够运用栈的 LIFO 特性来分析和解决实际问题，例如数制转换、括号匹配等 。