## 1. 核心思想：字符串的数字化指纹

滚动哈希的本质是一种巧妙的降维打击。它将一个**可变长度的字符串**映射（或称“哈希”）成一个**固定长度的整数**，这个整数就如同字符串的“指纹”。通过比较指纹，我们可以极大地加速判断两个字符串是否相等的过程。

这种映射的核心技术是**多项式哈希 (Polynomial Hashing)**。其基本逻辑是，将一个字符串 S 视作一个特定**基数 (base)** P 的数字。

对于一个长度为 L 的字符串 $S=s_0s_1...s_{L−1}$，其哈希值 $H(S)$ 定义如下：

$H(S) = \left( \sum_{i=0}^{L-1} s_i \cdot P^{L-1-i} \right) \pmod{M}$

其中：

- $s_i$: 字符串中第 i 个字符的数值表示（通常是其 ASCII 码）。

- P: 一个选定的质数，其值应大于**字符集**的大小（例如，对于纯小写字母，`a-z` 共 26 个，我们可以选择 P=31）。

- M: 一个选定的巨大质数，称为**模数 (modulus)**。它的作用是防止计算结果溢出，同时通过取模运算将哈希值约束在一个可控范围内，并降低冲突概率。

这个公式的直观理解是，我们将字符串 `'abc'` 视为 $a\cdot P^2+b\cdot P^1+c\cdot P^0$ 这个 P 进制数。

## 2. “滚动”的精髓：O(1) 窗口更新

如果仅仅是为每个子串都独立计算一次哈希值，那么该算法的效率提升有限。滚动哈希的真正威力在于，当我们的观察窗口在文本上滑动时，它能够以**常数时间复杂度** O(1) 从旧窗口的哈希值推导出新窗口的哈希值。

假设我们有一个长度为 L 的窗口。当它从覆盖子串 S\[i..i+L−1\] 向右移动一格，变为覆盖 S\[i+1..i+L\] 时：

- **旧窗口的哈希值** $H_{old}$:
  
    $$H_{old} = (s_i \cdot P^{L-1} + s_{i+1} \cdot P^{L-2} + \dots + s_{i+L-1} \cdot P^0) \pmod{M}
  
    $$

- **新窗口的哈希值** $H_{new}$:
  
    $$H_{new} = (s_{i+1} \cdot P^{L-1} + s_{i+2} \cdot P^{L-2} + \dots + s_{i+L} \cdot P^0) \pmod{M}
  
    $$

观察二者的关系，我们可以通过三步操作从 $H_{old}$ 得到 $H_{new}$:

1. **移除旧信息**：从 $H_{old}$ 中减去最左侧字符 $s_i$ 的贡献。它的贡献值为 $s_i\cdot P^{L−1}$。
   
    $$H' = H_{old} - s_i \cdot P^{L-1}
   
    $$

2. **整体升位**：将剩余部分的哈希值整体乘以基数 P，相当于将每个字符的权重都提高一次方。
   
    $$H'' = H' \cdot P = (H_{old} - s_i \cdot P^{L-1}) \cdot P
   
    $$

3. **加入新信息**：加上新进入窗口的最右侧字符 $s_{i+L}$ 的贡献。它的贡献值就是 $s_{i+L}$ (即 $s_{i+L} \cdot P^0$) 。
   
    $$H_{new} = H'' + s_{i+L} = (H_{old} - s_i \cdot P^{L-1}) \cdot P + s_{i+L}
   
    $$
   将上述所有运算置于模 M 的体系下，最终的递推公式为：

$H_{new}​=((H_{old}​−s_i​⋅P^{L−1}\pmod M)⋅P+s_{i+L}​)\pmod M$

其中，$P^{L−1}\pmod M$ 这个值可以预先计算并存储起来，使得每次更新都只涉及一次减法、一次乘法和一次加法，从而实现了 O(1) 的高效更新。

## 3. 实现细节与关键考量

### a. 哈希冲突 (Hash Collision)

**这是滚动哈希最重要的理论局限。** 由于我们将一个庞大的字符串空间映射到一个有限的整数空间，必然存在两个不同的字符串产生相同哈希值的可能性。

- **解决方案**：
  
  1. **二次确认**：当发现哈希值匹配时，不能直接断定字符串相等。必须进行一次**逐字符的暴力比较**来最终确认。因此，滚动哈希通常用作一个快速的**筛选器**，剔除大量不匹配的情况。
  
  2. **双哈希 (Double Hashing)**：为了将冲突概率降至极低，可以采用两组不同的基数 P 和模数 M（例如，$P_1,M_1$ 和 $P_2,M_2$）来计算两个独立的哈希值。只有当两个哈希值都相同时，我们才认为字符串可能匹配。

### b. 模运算中的减法

在计算 $H_{old}−s_i\cdot P^{L−1}$ 时，结果可能为负数。在模运算中，需要将其转换为等价的正数。标准的处理方式是：

$(a−b)(\mod M)≡(a−b+M)(\mod M)$

这样可以保证结果始终在 \[0,M−1\] 的范围内。

### c. 参数选择

- **基数** P: 必须是一个质数，且大于字符集的种类数。这能最大化地利用每一位字符的信息，减少冲突。

- **模数** M: 必须是一个足够大的质数。通常选择像 $10^9+7$, $10^9+9$ 这样的大质数，或者 `long long` 范围内的随机大质数。选择质数可以使哈希值的分布更均匀。

## 4. 伪代码示例

以下是使用滚动哈希在文本 `text` 中查找模式串 `pattern` 的伪代码（Rabin-Karp 算法的核心部分）。

```c
function RabinKarp(text, pattern):
  N = length(text)
  L = length(pattern)
  P = 31
  M = 10^9 + 7

  // 1. 预计算 P^(L-1) mod M
  P_L_MINUS_1 = power(P, L - 1) mod M

  // 2. 计算 pattern 和 text 第一个窗口的哈希值
  hash_pattern = 0
  hash_text_window = 0
  for i from 0 to L - 1:
    hash_pattern = (hash_pattern * P + pattern[i]) mod M
    hash_text_window = (hash_text_window * P + text[i]) mod M

  // 3. 开始滚动比较
  for i from 0 to N - L:
    // a. 比较当前窗口的哈希值
    if hash_pattern == hash_text_window:
      // 哈希值匹配，进行二次确认
      if pattern == text.substring(i, L):
        print("Pattern found at index " + i)

    // b. 如果还有下一个窗口，计算其哈希值
    if i < N - L:
      // 移除旧字符
      term_to_remove = (text[i] * P_L_MINUS_1) mod M
      hash_text_window = (hash_text_window - term_to_remove + M) mod M
      // 升位
      hash_text_window = (hash_text_window * P) mod M
      // 加入新字符
      hash_text_window = (hash_text_window + text[i + L]) mod M
```

## 5. 应用场景

滚动哈希是解决一系列字符串问题的强大工具：

- **Rabin-Karp 算法**：经典的字符串匹配算法。

- **查找最长重复子串**：通过对不同长度的子串进行哈希，结合二分查找，可以高效地找到最长的重复子串。

- **文件去重/比较**：将文件内容分块，计算每个块的哈希值，快速比较文件的异同。