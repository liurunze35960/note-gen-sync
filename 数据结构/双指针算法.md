双指针法是一种非常高效的算法技巧，它通过使用两个索引指针在一个数据结构（通常是数组或链表）上移动，从而在一次遍历中解决问题。这种方法能巧妙地将一些问题的时间复杂度从 O(n2) 优化到 O(n)，在处理大规模数据时效果显著。

## 剑客一：左右指针 (对撞指针)

这种方法是双指针中最直观的一种，两个指针从数组的两端开始，相向而行，直到相遇。

- **核心思想**：利用数据的有序性，从两端向中间逼近，不断缩小解空间。
    
- **起手式**：一个 `left` 指针指向数组开头 (索引`0`)，一个 `right` 指针指向数组末尾 (索引 `n-1`)。
    
- **适用场景**：主要用于**已排序**的数组中，寻找满足特定条件的**一对元素**。
     

### 代码示例：两数之和 II (LeetCode 167)

**问题**：在一个已升序排序的数组中，找到两个数，使它们的和等于一个特定的目标值。

```CPP
#include <iostream>
#include <vector>

// 函数：寻找两个数的和等于目标值
std::vector<int> twoSum(std::vector<int>& numbers, int target) {
    // 1. 初始化左右指针
    int left = 0;
    int right = numbers.size() - 1;

    // 2. 循环直到两个指针相遇
    while (left < right) {
        int sum = numbers[left] + numbers[right];
        if (sum == target) {
            // 找到了，返回索引（题目要求索引从1开始）
            return {left + 1, right + 1};
        } else if (sum < target) {
            // 和太小了，需要一个更大的数，所以移动左指针
            left++;
        } else if (sum > target){
            // 和太大了，需要一个更小的数，所以移动右指针
            right--;
        }
    }
    // 如果找不到，返回空数组
    return {};
}

int main() {
    std::vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    std::vector<int> result = twoSum(nums, target);
    std::cout << "在数组 [2, 7, 11, 15] 中寻找和为 " << target << " 的两个数..." << std::endl;
    std::cout << "找到的索引是: [" << result[0] << ", " << result[1] << "]" << std::endl;
    // 输出: [1, 2]
    return 0;
}
```

## 剑客二：快慢指针 (龟兔赛跑)

这种方法让两个指针以不同的速度在数据结构上移动，通过它们之间的速度差来解决问题。

- **核心思想**：利用速度差，快指针走过的距离和慢指针走过的距离会形成特定关系（如两倍关系），从而定位到特殊节点。
    
- **起手式**：一个 `slow` 指针和一个 `fast` 指针通常都从起点出发。`slow` 每次移动一步，`fast` 每次移动两步。
    
- **适用场景**：主要用于**链表**结构中，解决例如**判断链表是否有环**、**寻找链表中点**、**寻找倒数第k个节点**等问题。
    

### 代码示例：寻找链表的中点 (LeetCode 876)

**问题**：给定一个单链表的头结点，找到链表的最中间的结点。

```CPP
#include <iostream>

// 定义链表节点结构
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// 函数：寻找链表的中点
ListNode* findMiddleNode(ListNode* head) {
    // 1. 初始化快慢指针，都指向头结点
    ListNode* slow = head;
    ListNode* fast = head;

    // 2. 移动指针
    // 条件：fast 和 fast->next 都不能是空指针，以防 fast 越界
    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;      // 慢指针走一步
        fast = fast->next->next; // 快指针走两步
    }
    
    // 当循环结束时，fast 已经到达或越过链表末尾
    // 此时 slow 正好位于中点
    return slow;
}

int main() {
    // 创建一个链表: 1 -> 2 -> 3 -> 4 -> 5
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    std::cout << "在链表 [1,2,3,4,5] 中寻找中点..." << std::endl;
    ListNode* middle = findMiddleNode(head);
    std::cout << "中点的值是: " << middle->val << std::endl;
    // 输出: 3
    return 0;
}
```

## 剑客三：滑动窗口

这种方法用两个指针构成一个“窗口”，通过移动指针来“滑动”这个窗口，以处理窗口内的**连续元素**。

- **核心思想**：维护一个满足特定条件的窗口，通过移动左右边界来不断更新窗口状态，从而避免重复计算。
    
- **起手式**：`left` 和 `right` 指针通常都从起点出发。`right` 负责扩张窗口，`left` 负责收缩窗口。
    
- **适用场景**：主要用于解决**连续子数组**或**连续子字符串**的问题，如“求最长/最短的满足...的子数组”。
    

### 代码示例：长度最小的子数组 (LeetCode 209)

**问题**：给定一个含有 n 个正整数的数组和一个正整数 target，找出该数组中满足其和 ≥ target 的长度最小的连续子数组。

```CPP
#include <iostream>
#include <vector>
#include <algorithm>
#include <climits> // 用于 INT_MAX

// 函数：寻找和大于等于target的最小长度子数组
int minSubArrayLen(int target, std::vector<int>& nums) {
    int n = nums.size();
    int minLength = INT_MAX; // 初始化最小长度为一个极大值
    int currentSum = 0;
    int left = 0; // 窗口的左边界

    // right 是窗口的右边界，负责扩张窗口
    for (int right = 0; right < n; ++right) {
        // 1. 将新元素加入窗口，扩大窗口
        currentSum += nums[right];

        // 2. 检查窗口是否满足条件 (sum >= target)
        while (currentSum >= target) {
            // 如果满足，更新最小长度
            minLength = std::min(minLength, right - left + 1);

            // 3. 尝试收缩窗口，移动左边界
            currentSum -= nums[left];
            left++;
        }
    }

    // 如果 minLength 没有被更新过，说明没有找到满足条件的子数组
    return (minLength == INT_MAX) ? 0 : minLength;
}

int main() {
    std::vector<int> nums = {2, 3, 1, 2, 4, 3};
    int target = 7;
    std::cout << "在数组 [2,3,1,2,4,3] 中寻找和>=7的最小长度子数组..." << std::endl;
    int result = minSubArrayLen(target, nums);
    std::cout << "最小长度是: " << result << std::endl;
    // 输出: 2 (因为子数组 [4,3] 的和是7，长度为2)
    return 0;
}
```