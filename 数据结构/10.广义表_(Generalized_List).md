广义表是线性表的推广，是一种功能更强大的数据结构。它在人工智能领域的LISP语言中被广泛使用。与普通线性表不同，广义表的元素本身也可以是一个广义表，从而形成了多层次的复杂结构。

## 一、 广义表的定义与基本概念

### 1. 概念

广义表 (Generalized List, 简称 GL) 是由 n ($n\ge0$) 个表元素组成的有限序列。

其标准形式记作：GL=(a1​,a2​,a3​,...,an​)

其中：

- **GL** 是广义表的名称。
    
- $a_i$ 是**广原子 (Atom)**：单个的数据元素，其值不可再分。
    
- **子表 (Sublist)**：本身也是一个广义表。
    

### 2. 重要术语

- **长度 (Length)**：广义表中所包含的元素的个数，即 n。
    
- **空表 (Empty List)**：长度为 0 的广义表，记作 `()`。
    
- **表头 (Head)**：当广义表非空时，其第一个元素（$a_1$）称为表头。表头可以是原子，也可以是子表。
    
- **表尾 (Tail)**：当广义表非空时，除表头之外，由其余所有元素（$a_2,a_3,...,a_n$）构成的广义表称为表尾。**特别注意：表尾必定是一个广义表**。
    

**示例分析:**

- A=()  
    
    - 空表，长度为 0。
        
    - 没有表头，也没有表尾。
        
- B=(x,y,z)  
    
    - 这是一个只包含原子的广义表。
        
    - 长度为 3。
        
    - 表头 `Head(B)` 是原子 `x`。
        
    - 表尾 `Tail(B)` 是广义表 `(y, z)`。
        
- C=(B,y,z)=((x,y,z),y,z)  
    
    - 这是一个包含子表的广义表。
        
    - 长度为 3。
        
    - 表头 `Head(C)` 是子表 `B`，即 `(x, y, z)`。
        
    - 表尾 `Tail(C)` 是广义表 `(y, z)`。
        
- D=(x,(y,z))  
    
    - 长度为 2。
        
    - 表头 `Head(D)` 是原子 `x`。
        
    - 表尾 `Tail(D)` 是广义表 `((y, z))`。注意这里有两层括号。
        
- E=(x,E)  
    
    - 这是一个递归表，它直接或间接地包含了自身。
        
    - 长度为 2。
        
    - 表头 `Head(E)` 是原子 `x`。
        
    - 表尾 `Tail(E)` 是广义表 `(E)`。
        

### 3. 广义表的深度 (Depth)

广义表的深度是衡量其嵌套层次的指标，通常定义为广义表表达式中括号的最大嵌套层数。

递归定义:

$$
\text{Depth}(GL) = 
\begin{cases} 
0 & \text{GL为原子元素} \\
1 & \text{GL为空表} \\
1 + \text{Max}\{\text{Depth}(a_i) \mid 1 \le i \le n\} & \text{其它情况} 
\end{cases}
$$


**示例分析:**

- A=()  
    
    - 深度为 1。
        
- B=(x,y,z)  
    
    - 深度为 1，因为所有元素都是原子，原子的深度视为0，所以 1+max(0,0,0)=1。
        
- D=(x,(y,z))  
    
    - 深度为 2。$1+max(\text{Depth(x)},\text{Depth((y,z))})=1+max(0,1)=2$。
        
- E=(x,E)  
    
    - 递归表，深度为无穷大 ($\infty$)。
        

### 4. 广义表的特性

- **有序性**：表内元素之间==存在次序关系==。
    
- **可变长度**：表的长度不是固定的。
    
- **多层次性（深度）**：元素可以是子表，形成嵌套结构。
    
- **可共享**：一个子表可以被多个不同的广义表所共享，节省存储空间。
    
- **可递归**：一个广义表可以是其自身的子表。
    

## 二、 广义表的基本操作

任何一个非空广义表 $GL=(a_1,a_2,...,a_n)$ 都可以被分解为表头 `Head(GL)` 和表尾 `Tail(GL)` 两部分。反之，一个表头和一个表尾也可以唯一地确定一个广义表。

**核心操作:**

- **`First()` / `Head()`**: 取表头。
    
- **`Next()` / `Tail()`**: 取表尾。
    

**嵌套操作示例:**

对于广义表 B=(a,(b,c,d)):

- `Head(B)` = a  
    
- `Tail(B)` = ((b,c,d))  
    
- `Head(Head(Tail(B)))` = (b,c,d)  
    
- `Head(Head(Head(Tail(B))))` = b  
    
- `Tail(Head(Head(Tail(B))))` = (c,d)  
    
**其他操作：**
- GenListNode\<ElemType\> \*First() const
	在广义表存在的情况下，返回广义表的第一个元素。
	
- GenListNode\<ElemType\> \*Next(GenListNode\<ElemType\> \*elemPtr) const
	在广义表存在的情况下，返回elemPtr 指针指向的广义表元素的后继。
	
- Bool Empty () const
	检测广义表是否为空。
	
- Void Push (const ElemType &e)
	将 e 作为表头加入到最前面
	
- Void Push (GenList\<ElemType\> &subList)
	将 subList 作为表头加入到最前面
	
- Int Depth ()
	返回广义表的深度
	

---
## 三、 广义表的存储结构

由于广义表元素的结构多样性，不适合使用顺序存储结构。通常采用**链式存储结构**。
==（更多离散逻辑性）==
### 头尾链表表示法

这是一种常用的链式存储方法，其结点结构通常包含三个字段：标志位(tag)、数据/指针域、后继指针域。

**结点类型:**

1. **原子结点**:
    
    - `tag = 0` (或某个特定值区分原子、表和头节点)
        
    - `atom` 域：存放原子的值。
        
    - `nextLink` 域：指向下一个表元素的指针。
        
2. **表结点 (子表结点)**:
    
    - `tag = 1` (或某个特定值表示表)
        
    - `subLink` 域：指向该子表对应的头结点的指针。
        
    - `nextLink` 域：指向下一个表元素的指针。
        

为了便于操作，通常会为每个广义表（包括子表和空表）增加一个**头结点**。头结点的 `nextLink` 指向表的第一个元素结点。

### 扩展：带引用计数的头尾链表

在支持共享的广义表中，为了正确地管理内存（特别是释放不再被引用的结点），可以在头结点中增加一个**引用计数 (reference count)** 域。

- **`ref`**: 记录当前有多少个指针指向该头结点。
    
- 当一个新的指针指向该头结点时，`ref` 加 1。
    
- 当一个指针不再指向该头结点时，`ref` 减 1。
    
- 当 `ref` 减为 0 时，说明该表不再被任何地方引用，可以安全地释放其占用的所有空间。
    
![[10.广义表 (Generalized List)-1754799266583.webp]]
## 四、 广义表操作的递归实现

广义表的递归定义特性，使其许多操作非常适合用递归算法来实现。这体现了**分治法 (Divide and Conquer)** 的思想：将一个复杂问题分解为规模更小的相同或相似的子问题，递归地解决这些子问题，然后将子问题的解合并，得到原问题的解。

### 示例1：求广义表的深度

```c
int GetDepth(GeneralizedList GL) {
    if (GL is empty) {
        return 1;
    }
    if (GL is an atom) {
        return 0;
    }
    
    int maxSubDepth = 0;
    // 遍历表中的每一个元素
    for (each element p in GL) {
        int currentSubDepth = GetDepth(p); // 递归求解元素的深度
        if (currentSubDepth > maxSubDepth) {
            maxSubDepth = currentSubDepth;
        }
    }
    
    return maxSubDepth + 1;
}
```

### 示例2：复制广义表

```c
// 伪代码
GeneralizedList CopyList(GeneralizedList GL) {
    if (GL is empty) {
        return create an empty list;
    }
    
    GeneralizedList NewGL = create a new list head;
    
    // 遍历原表中的每一个元素
    for (each element p in GL) {
        if (p is an atom) {
            copy the atom and append to NewGL;
        } else { // p is a sublist
            // 递归复制子表
            GeneralizedList copiedSubList = CopyList(p);
            append the copiedSubList to NewGL;
        }
    }
    
    return NewGL;
}
```