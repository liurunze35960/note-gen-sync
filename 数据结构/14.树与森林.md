## 一、 树的存储结构

### (1) 双亲表示法

这种方法采用一组连续的内存空间来存储树的所有结点，并通过记录每个结点的父结点（双亲）在数组中的位置来体现结点间的逻辑关系。

> 如果说数组和链表是路，那么树就是网状结构
> 数组等至多只有一个前驱和后驱，但是树有且仅有一个前驱的同时可以拥有许多后驱

- **数据结构:**
    
    - `data`: 存储结点的数据。
        
    - `parent`: 存储该结点的双亲结点在数组中的索引。根结点的 `parent` 通常设为 -1。
        
- **结点类定义示例:**
    
    ```c
    struct ParentTreeNode {
        ElemType data; // 结点数据
        int parent;   // 双亲位置域（双亲的下标）
    };
    ```
    
- 示例:
    
    对于一棵给定的树，其双亲表示法如下表所示：
    

|   |   |   |
|---|---|---|
|**索引**|**data**|**parent**|
|0|A|-1|
|1|B|0|
|2|C|0|
|3|D|1|
|4|E|1|
|5|F|2|
|6|G|4|
|7|H|4|
|8|I|4|

### (2) 孩子双亲表示法

为了方便查找一个结点的孩子，这种方法在双亲表示法的基础上进行了扩展。它将每个结点的所有孩子结点组织成一个线性表（如链表）。 这种结构结合了双亲指针和指向孩子结点的链表。

- **结点类定义示例:**
    
    ```c
    struct ChildParentTreeNode {
        ElemType data;         // 结点数据
        int parent;            // 双亲位置域
        LinkList childLkList;  // 指向孩子链表的指针
    };
    ```
    

### (3) 孩子兄弟表示法

这是最常用的一种树的存储结构，也称为“二叉链表表示法”。它使用二叉链表的结构来存储树，其中每个结点有两个指针域：

- `firstChild`: 指向该结点的第一个孩子结点。
    
- `rightSibling`: 指向该结点的下一个兄弟结点。
    

通过这种方式，任何树或森林都可以唯一地对应一棵二叉树。

- **结点类定义示例:**
    
    ```c
    struct ChildSiblingTreeNode {
        ElemType data;
        ChildSiblingTreeNode *firstChild;     // 指向第一个孩子
        ChildSiblingTreeNode *rightSibling; // 指向右侧兄弟
    };
    ```
    

## 二、 森林和二叉树的转换

树和森林可以通过孩子兄弟表示法（二叉链表）作为中介，与二叉树进行相互转换。

### 1. 树转换为二叉树

转换规则非常直接：

- 树的根结点作为二叉树的根结点。
    
- 对于树中的任意结点 `X`，它的**第一个孩子**是转换后二叉树中 `X` 结点的**左孩子**。
    
- 对于树中的任意结点 `X`，它的**紧邻的右兄弟**是转换后二叉树中 `X` 结点的**右孩子**。
    

### 2. 森林转换为二叉树

森林是多棵树的集合。 转换时，可以将森林中的各棵树的根结点看作是兄弟关系。

**转换步骤:**

1. 将森林中的第一棵树 $T_1$ 按照“树转二叉树”的规则转换成二叉树 $B_1$。
    
2. 将森林中的第二棵树 T_2 同样转换成二叉树 B_2，然后将 B_2 作为 B_1 根结点的**右子树**。
    
3. 依次将后续的树转换成二叉树，并分别挂到前一棵树转换后的二叉树的根结点的右子树上。
    
4. 最终得到的一整棵二叉树即为该森林的二叉树表示。
    

递归定义:

设森林 F=T_1,T_2,...,T_m，对应的二叉树为 B=root,LB,RB。

- 若 F 为空 (m=0)，则 B 也为空树。
    
- 若 F 非空 (m0):
    
    - 二叉树 B 的根 `root` 是第一棵树 T_1 的根。
        
    - B 的左子树 `LB` 是由 T_1 的子树森林 F_1 转换而来的二叉树。
        
    - B 的右子树 `RB` 是由森林中剩下的树 F′=T_2,T_3,...,T_m 转换而来的二叉树。
        

> 练习题思考
> 
> 设森林F由T1, T2, T3三棵树组成，结点数分别为 n_1,n_2,n_3。与F对应的二叉树为B。
> 
> - B的根是T1的根。
>     
> - B的左子树由T1的子树森林构成，因此其结点数为 n_1−1。
>     
> - B的右子树由森林 T_2,T_3 构成，因此其结点数为 n_2+n_3。
>     

### 3. 二叉树转换为森林

这是森林转换为二叉树的逆过程。

转换规则:

设二叉树为 B，要转换为森林 F。

- 若 B 为空，则 F 也为空。
    
- 若 B 非空:
    
    1. B 的根结点 `root` 是森林 F 中第一棵树 $T_1$ 的根。
        
    2. B 的**左子树** `LB` 按照“二叉树转森林”的规则递归转换，得到 $T_1$ 的子树森林。
        
    3. B 的**右子树** `RB` 按照“二叉树转森林”的规则递归转换，得到森林 F 中除 $T_1$ 之外的其余树组成的森林 $F'=T_2,T_3,...,T_m$。
        

## 三、 哈夫曼树 (Huffman Tree)

### 1. 基本概念

- **路径 (Path):** 从一个结点到另一个结点所经过的分支序列。
    
- **路径长度 (Path Length):** 路径上分支的数量。
    
- **结点的路径长度:** 从根结点到该结点的路径长度。
    
- **树的路径长度 (PL):** 树中所有**叶子结点**的路径长度之和。
    
- **结点的权 (Weight):** 根据应用需求赋予结点的数值。
    
- **结点的带权路径长度:** 从根到该结点的路径长度与该结点权值的乘积。
    
- 树的带权路径长度 (WPL, Weighted Path Length): 树中所有叶子结点的带权路径长度之和。
    
    WPL=k=1∑n​wk​lk​
    
    其中 w_k 是第 k 个叶子结点的权值， l_k 是该叶子结点的路径长度。
    
- **哈夫曼树 (Huffman Tree):** 对于给定的n个权值，作为n个叶子结点的权，所构造出的**WPL最小**的二叉树。也称为**最优二叉树**。
    

> **核心思想:** 要使树的带权路径长度WPL最小，必须使权值大的叶子结点更靠近根结点，即路径长度更短。

### 2. 哈夫曼树的构造算法

哈夫曼算法采用贪心策略，每次选择权值最小的结点进行合并。

**步骤:**

1. **初始化:** 根据给定的 n 个权值 w_1,w_2,...,w_n，构造 n 棵只包含一个根结点的二叉树，并将这 n 棵树放入一个集合（森林）F 中。
    
2. **合并:** 在集合 F 中，选取根结点权值**最小**的两棵树，将它们作为左、右子树，构造一棵新的二叉树。新树的根结点权值为其左、右子树根结点权值之和。
    
3. **更新:** 从集合 F 中删除被选中的那两棵树，并将新生成的树加入 F 中。
    
4. **重复:** 重复步骤2和3，直到集合 F 中只剩下一棵树为止。这棵树就是最终的哈夫曼树。
    

### 3. 哈夫曼编码

**背景:** 在数据通信中，需要将字符转换为二进制字符串进行传输，这个过程就是编码。

- **等长编码:** 所有字符的二进制编码长度相同。译码简单但可能不是最高效的。
    
- **不等长编码:** 不同字符的编码长度不同。如果设计不当，可能会产生译码歧义。例如，若 A=0, B=00，则 "00" 无法确定是 AA还是 B。
    

**前缀编码 (Prefix Code):**

一种解决了不等长编码歧义的编码方式。其核心要求是：任何一个字符的编码都不是另一个字符编码的前缀。 哈夫曼编码就是一种最优的前缀编码。

**生成哈夫曼编码:**

1. **统计频率:** 统计待编码字符集中的每个字符出现的频率（或次数），将频率作为权值。
    
2. **构造哈夫曼树:** 以上述权值为基础，构造一棵哈夫曼树。
    
3. **分配编码:** 在哈夫曼树上，从根结点开始，为每条指向左子树的分支分配 '0'，指向右子树的分支分配 '1'。
    
4. **获取编码:** 从根结点到每个叶子结点的路径上，将经过的分支代码（0或1）依次连接起来，就构成了该叶子结点对应字符的哈夫曼编码。
    

> **优点:** 对于出现频率高的字符，其在哈夫曼树中的位置靠近根，路径短，编码也短。对于频率低的字符，其位置远离根，路径长，编码也长。这样使得总的编码长度期望值最小，达到了数据压缩的目的。

### 4. 哈夫曼树与编码的实现

#### a. 数据结构

使用一个结构体数组来存储哈夫曼树的所有结点（包括叶子和非叶子）。

```c
#define N 20      // 假设叶子结点数量
#define M 2*N-1 // 所有结点数量（哈夫曼树的总结点数是 2n-1）

typedef struct {
    int weight;   // 权值
    int parent;   // 双亲结点的索引
    int LChild;   // 左孩子的索引
    int RChild;   // 右孩子的索引
} HTNode, HuffmanTree[M+1]; // HTNode是结点类型，HuffmanTree是存储树的数组
```

#### b. 构造哈夫曼树的伪代码

```c
void CrtHuffmanTree(HuffmanTree ht, int w[], int n) {
    // n是叶子结点的数量, w[]存放叶子结点的权值
    int m = 2 * n - 1;

    // 初始化所有结点
    // 1 to n 为叶子结点
    for (int i = 1; i <= n; i++) {
        ht[i] = {w[i], 0, 0, 0}; // 权值设为w[i]，其他域为0(表示空)
    }
    // n+1 to m 为非叶子结点
    for (int i = n + 1; i <= m; i++) {
        ht[i] = {0, 0, 0, 0}; // 初始化为0
    }

    // 构造非叶子结点
    for (int i = n + 1; i <= m; i++) {
        // 在ht[1...i-1]中选择两个parent为0且weight最小的结点s1和s2
        select(ht, i - 1, &s1, &s2); 

        // 合并s1和s2
        ht[s1].parent = i;
        ht[s2].parent = i;
        ht[i].LChild = s1;
        ht[i].RChild = s2;
        ht[i].weight = ht[s1].weight + ht[s2].weight;
    }
}
```

#### c. 生成哈夫曼编码的伪代码

这个算法从每个叶子结点出发，沿着其父指针向上回溯到根，逆向求出编码。

```
typedef char* HuffmanCode[N+1]; // 存储编码串的指针数组

void CrtHuffmanCode(HuffmanTree ht, HuffmanCode hc, int n) {
    char* cd = (char*)malloc(n * sizeof(char)); // 分配临时存放编码的工作空间
    cd[n-1] = '\0'; // 编码结束符

    for (int i = 1; i <= n; i++) { // 对每个叶子结点求编码
        int start = n - 1; // 编码结束符位置，从后向前填充
        int c = i;         // 当前结点，从叶子开始
        int p = ht[c].parent; // 当前结点的父结点

        while (p != 0) { // 回溯到根结点
            start--; // 向前移动指针
            if (ht[p].LChild == c) {
                cd[start] = '0'; // 是左孩子，编码为0
            } else {
                cd[start] = '1'; // 是右孩子，编码为1
            }
            c = p; // 继续向上回溯
            p = ht[c].parent;
        }

        // 为第i个字符的编码分配空间并复制
        hc[i] = (char*)malloc((n - start) * sizeof(char));
        strcpy(hc[i], &cd[start]);
    }
    free(cd); // 释放工作空间
}
```