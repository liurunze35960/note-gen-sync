## **第一章：树的基础理论**

### **1.1 树的定义与特性**

- **定义**：树（Tree）是由 n（$n\ge0$）个结点组成的有限集合。
    
    - 当 n=0 时，称为**空树**。
        
    - 在任意非空树中：
        
        1. 有且仅有一个特定的称为**根**（Root）的结点。
            
        2. 当 $n\ge1$ 时，其余结点可分为 m（$m\ge0$）个互不相交的有限集合 $T_1,T_2,...,T_m$，其中每一个集合本身又是一棵树，称为根的**子树**（Subtree）。
            
- **核心特性**：
    
    - **非线性结构**：主要描述数据元素之间的层次和分支关系。
        
    - **唯一前驱**：除根结点外，每个结点有且仅有一个**双亲**（前驱）。
        
    - **多个后继**：任意结点可以有零个或多个**孩子**（后继）。
        
    - **应用**：组织结构图、计算机文件系统、家族族谱等。
        

### **1.2 核心术语**

- **结点（Node）**：树的基本组成单位，包含数据元素和指向子树的分支。
    
- **结点的度（Degree）**：结点拥有的子树个数（或孩子个数）。
    
- **叶子结点（Leaf）**：度为 0 的结点，也称终端结点。
    
- **分支结点**：度不为 0 的结点，也称非终端结点。
    
- **树的度**：树中所有结点度的最大值。
    
- **层次（Level）**：根为第 1 层，其孩子为第 2 层，以此类推。
    
- **深度/高度（Depth/Height）**：树中结点的最大层次。
    
- **森林（Forest）**：m（$m\ge0$）棵互不相交的树的集合。
    

## **第二章：二叉树 (Binary Tree)**

### **2.1 二叉树的定义**

二叉树是一种特殊的树，其定义为：或者是一棵空树，或者是由一个根结点与两棵互不相交的、分别称为**左子树**和**右子树**的二叉树组成。

- **关键特征**：
    
    1. **度数限制**：每个结点的度**最多为 2**。
        
    2. **有序性**：左、右子树有严格的顺序，**不可颠倒**。
        

### **2.2 二叉树的重要性质**

1. 在二叉树的第 i 层上，至多有 $2^{i−1}$ 个结点 ($i\ge1$)。
    
2. 深度为 k 的二叉树，至多有 $2^k−1$ 个结点 ($k\ge1$)。
    
3. 对于任意二叉树，若其叶子结点数为$n_0$，度为 2 的结点数为 $n_2$，则 $n_0=n_2+1$。
    

### **2.3 特殊的二叉树**

- **满二叉树**：一棵深度为 k 且有 $2^k−1$ 个结点的二叉树。其特点是树中的每一层都含有最多(每个节点都有 2 度)的结点。
    
- **完全二叉树**：一棵深度为 k，有 n 个结点的二叉树，其结点编号（从1开始，按层序）与深度为 k 的满二叉树中编号为 1 到 n 的结点一一对应。
    
    - **性质 4**：具有 n 个结点的完全二叉树的深度为 $\lfloor log_2n\rfloor +1$。
        
    - **性质 5**：对于按层序编号的完全二叉树中的任一结点 i：
        
        - 其双亲结点编号为 $\lfloor i/2\rfloor$ (当 $i\ge1$ 时)。
            
        - 其左孩子结点编号为 2i (当 $2i\le n$ 时)。
            
        - 其右孩子结点编号为 2i+1 (当 $2i+1\le n$ 时)。
            

### **2.4 二叉树的存储结构**

1. **顺序存储**：
    
    - 使用**数组**按层序存储结点。
        
    - **优点**：结构简单，对于**完全二叉树**能高效利用空间并方便地计算父子关系。
        
    - **缺点**：对于非完全二叉树，尤其是**形态稀疏**的树，会造成极大的**空间浪费**。
    
2. **链式存储 (二叉链表)**：
    
    - ==最常用的方式==，每个结点包含**数据域**、**左孩子指针**和**右孩子指针**。
        
    - **C定义**：
        
        ```c
        typedef struct BiTNode {
            ElemType data; // 数据域
            struct BiTNode *LChild, *RChild; // 左右孩子指针
        } BiTNode, *BiTree;
        ```
        

## **第三章：二叉树的遍历**

遍历是指按某种预定次序，系统地访问树中的所有结点，且每个结点仅被访问一次。

### **3.1 主要遍历方法**

- **先序遍历 (Pre-order)**：**根** → 左子树 → 右子树 (TLR)
    
- **中序遍历 (In-order)**：左子树 → **根** → 右子树 (LTR)
    
- **后序遍历 (Post-order)**：左子树 → 右子树 → **根** (LRT)
    
- **层次遍历 (Level-order)**：从上到下，从左到右，逐层访问。
    

### **3.2 遍历算法实现**

#### **递归实现**

递归算法代码简洁，与树的定义高度契合。

- **先序遍历**
    
    ```c
    void PreOrder(BiTree T) {
        if (T != NULL) {
            visit(T); // 访问根结点
            PreOrder(T->LChild);
            PreOrder(T->RChild);
        }
    }
    ```
    
- **中序遍历**
    
    ```c
    void InOrder(BiTree T) {
        if (T != NULL) {
            InOrder(T->LChild);
            visit(T); // 访问根结点
            InOrder(T->RChild);
        }
    }
    ```
    
- **后序遍历**
    
    ```c
    void PostOrder(BiTree T) {
        if (T != NULL) {
            PostOrder(T->LChild);
            PostOrder(T->RChild);
            visit(T); // 访问根结点
        }
    }
    ```
    

#### **非递归实现 (使用辅助栈)**

非递归算法通过栈来模拟递归的调用过程，效率更高。

- **中序遍历 (非递归)**
    
    - **思路**：指针`p`沿根的左侧链一路向下，将沿途结点全部入栈。当左路走尽，弹出一个结点并访问，然后将指针`p`转向该结点的右子树，重复此过程。
        
    
    ```c
    void InOrder_NonRecursive(BiTree T) {
        SeqStack S; InitStack(S);
        BiTNode *p = T;
        while (p || !IsEmpty(S)) {
            if (p) {
                Push(S, p); // 当前结点入栈
                p = p->LChild; // 扫描其左孩子
            } else {
                Pop(S, p); // 栈顶结点出栈
                visit(p); // 访问出栈结点
                p = p->RChild; // 扫描其右孩子
            }
        }
    }
    ```
    

#### **层次遍历 (使用辅助队列)**

- **思路**：使用队列实现。根结点首先入队，然后循环执行：结点出队并访问，再将其非空的左、右孩子依次入队。
    

```c
void LevelOrder(BiTree T) {
    SeqQueue Q; InitQueue(Q);
    BiTNode *p;
    if (T) EnterQueue(Q, T); // 根结点入队
    while (!IsEmpty(Q)) {
        OutQueue(Q, p); // 队头结点出队
        visit(p); // 访问
        if (p->LChild) EnterQueue(Q, p->LChild); // 左孩子入队
        if (p->RChild) EnterQueue(Q, p->RChild); // 右孩子入队
    }
}
```

## **第四章：树与二叉树的应用**

### **4.1 基于遍历的应用**

- **创建二叉树 (扩展先序)**：使用特殊符号（如 `.`）表示空子树，通过先序遍历的方式递归创建。
    
- **复制二叉树**：采用后序遍历的思想，先递归复制左右子树，再创建根结点连接它们。
    
- **计算结点数**：在遍历过程中，每访问一个结点，计数器加一。
    
- **计算树的高度**：树的高度 = `max(左子树高度, 右子树高度) + 1`。（算法利用递归）
    
- **打印树形结构**：可采用“==反向中序遍历==”（右-根-左）（好看），根据结点的层次打印缩进。
```
（原树）
       A 
	 /    \
    B    C
    
（打印后）
	 C
	A
	 B
 
```

```c
void PrintTree(BiTree bt, int nLayer)
{
	if(bt == NULL) return;
	PrintTree(bt->RChild,nLayer+1);
	for(int i=0;i<nLayer;i++)
	cout<<"";
	cout<<bt->data<<endl:
	PrintTree(bt->LChild, nLayer+1);
}

```
### **4.2 由遍历序列构造二叉树**

- **唯一确定条件**：
    
    - **可以**：`先序序列` + `中序序列`
        
    - **可以**：`后序序列` + `中序序列`
        
    - **不可以**：`先序序列` + `后序序列`
        
- **构造思想 (以“先序+中序”为例)**：
    
    1. **确定根**：先序序列的第一个元素即为当前树的根结点。
        
    2. **划分左右子树**：在中序序列中找到该根结点，其左侧所有元素构成左子树的中序序列，右侧所有元素构成右子树的中序序列。
        
    3. **确定子序列**：根据左、右子树的结点个数，在先序序列中找到对应的子序列。
        
    4. **递归构造**：对左、右子树递归执行以上步骤，直至序列为空。
```c++
#include <iostream>

// 假设 ElemType 是 char 类型，用于存储节点数据
using ElemType = char;

// 定义二叉树节点结构体
struct BiTNode {
    ElemType data;      // 节点数据域
    BiTNode *LChild;    // 左孩子指针
    BiTNode *RChild;    // 右孩子指针

    // 构造函数，方便用 new 创建节点时初始化
    BiTNode() : LChild(nullptr), RChild(nullptr) {}
};

// 为方便使用，定义 BiTree 类型为节点指针
using BiTree = BiTNode*;

/**
 * @brief 递归辅助函数：根据先序和中序遍历序列构造二叉树
 * @param r  一个引用参数，函数将通过它来构建并连接子树的根节点
 * @param pre 先序遍历序列数组
 * @param in 中序遍历序列数组
 * @param preLeft 当前处理的【先序序列】的起始下标
 * @param preRight 当前处理的【先序序列】的结束下标
 * @param inLeft 当前处理的【中序序列】的起始下标
 * @param inRight 当前处理的【中序序列】的结束下标
 */
void CreateBinaryTreeHelp(BiTNode*& r, ElemType pre[], ElemType in[], 
                          int preLeft, int preRight, int inLeft, int inRight) 
{
    // --- 递归的终止条件 ---
    // 如果中序（或先序）序列的范围无效（左边界大于右边界），
    // 说明当前子树没有节点，为空树。
    if (inLeft > inRight) {
        r = nullptr; // 将当前节点指针置为空，然后返回
        return;
    }

    // --- 递归的核心构建过程 ---
    
    // 1. 创建当前子树的根节点。
    // 根据先序遍历的特性，当前先序子序列的第一个元素 pre[preLeft] 必然是根。
    r = new BiTNode();
    r->data = pre[preLeft];

    // 2. 在中序子序列中找到根节点的位置（下标 mid）。
    // 这个位置将中序序列划分为两部分：左边是左子树，右边是右子树。
    int mid = inLeft;
    while (in[mid] != pre[preLeft]) {
        mid++;
    }

    // 3. 计算左子树的节点数量。
    // 这是连接先序和中序序列的关键，用于确定先序序列中左右子树的范围。
    int leftSubtreeSize = mid - inLeft;

    // 4. 递归构建左子树。
    // 左子树对应的先序序列是根节点之后的 leftSubtreeSize 个元素。
    // 左子树对应的中序序列是根节点 mid 左边的部分。
    CreateBinaryTreeHelp(
        r->LChild,                  // 要构建的是当前根节点 r 的左孩子
        pre, in,                    // 完整的序列数组
        preLeft + 1,                // 左子树先序序列的起始点
        preLeft + leftSubtreeSize,  // 左子树先序序列的结束点
        inLeft,                     // 左子树中序序列的起始点
        mid - 1                     // 左子树中序序列的结束点
    );

    // 5. 递归构建右子树。
    // 右子树对应的先序序列是紧跟在左子树序列之后的部分。
    // 右子树对应的中序序列是根节点 mid 右边的部分。
    CreateBinaryTreeHelp(
        r->RChild,                   // 要构建的是当前根节点 r 的右孩子
        pre, in,                     // 完整的序列数组
        preLeft + leftSubtreeSize + 1,// 右子树先序序列的起始点
        preRight,                    // 右子树先序序列的结束点
        mid + 1,                     // 右子树中序序列的起始点
        inRight                      // 右子树中序序列的结束点
    );
}


/**
 * @brief 主函数/封装函数：根据先序和中序序列构建二叉树
 * @param pre 完整的先序遍历序列数组
 * @param in 完整的中序遍历序列数组
 * @param n 树中节点的总数
 * @return 构建完成的树的根节点指针
 */
BiTree CreateBinaryTree(ElemType pre[], ElemType in[], int n) {
    BiTNode* root = nullptr; // 定义一个根节点指针，初始为空

    // 调用递归辅助函数，传入完整的序列范围 [0, n-1] 来启动整个构建过程
    CreateBinaryTreeHelp(root, pre, in, 0, n - 1, 0, n - 1);

    // 辅助函数通过引用修改了 root，现在 root 指向整棵树的根
    return root;
}

// --- 示例：如何使用 ---
// 
// void PostOrderTraverse(BiTree bt) { // 用于验证结果的后序遍历
//     if (bt == nullptr) return;
//     PostOrderTraverse(bt->LChild);
//     PostOrderTraverse(bt->RChild);
//     std::cout << bt->data << " ";
// }
//
// int main() {
//     char pre[] = {'A', 'B', 'D', 'E', 'C', 'F'};
//     char in[]  = {'D', 'B', 'E', 'A', 'F', 'C'};
//     int n = sizeof(pre) / sizeof(pre[0]);
//
//     BiTree myTree = CreateBinaryTree(pre, in, n);
//
//     // 期望的后序遍历结果: D E B F C A
//     std::cout << "后序遍历验证: ";
//     PostOrderTraverse(myTree);
//     std::cout << std::endl;
//
//     return 0;
// }
```