## 一、有向无环图（Directed Acyclic Graph, DAG）及其应用

### 1. 定义

有向无环图（DAG）是指一个没有回路（环）的有向图。它是描述许多实际系统中任务依赖关系的重要工具。

- **与有向树的区别**：有向树是一种特殊的DAG，其中每个节点（除了根节点）只有一个父节点。而DAG中一个节点可以有多个父节点。
    
- **判断方法**：判断一个有向图是否存在环，最常用的方法是**拓扑排序**。如果能对一个图进行完整的拓扑排序，那么这个图就是有向无环图。
    

### 2. 应用场景

有向无环图广泛应用于表示具有先后顺序或依赖关系的任务流程。

- **工程流程**：如大型建筑项目，某些子工程必须在其他子工程完成后才能开始。
    
- **生产流程**：制造业中，一道工序依赖于前一道工序的完成。
    
- **课程安排**：大学课程中，许多高级课程需要先修一些基础课程。
    

在这些应用中，我们主要关心两个核心问题：

1. **工程可行性**：整个流程是否“合理”，即是否存在循环依赖（死锁）？
	这可以通过**拓扑排序**来解决。
    
3. **工程效率**：完成整个工程至少需要多长时间？哪些任务是影响整体进度的“关键”？这需要通过**关键路径**分析来解决。
    

## 二、拓扑排序（Topological Sort）

### 1. AOV网（Activity on Vertex Network）

为了分析工程流程的合理性，我们通常使用AOV网。

- **定义**：AOV网是一种有向图，其中：
    
    - **顶点（Vertex）**：代表一个**活动（Activity）**或子工程。
        
    - **有向边（Arc）**：代表活动之间的**优先关系**。若存在一条从顶点A到顶点B的边，表示活动A必须在活动B之前完成。
        

### 2. 拓扑排序的定义

对一个有向无环图（AOV网）的顶点进行线性排序，使得对于图中任意一条有向边 `<u, v>`，顶点 `u` 在线性序列中都出现在顶点 `v` 之前。

- **结果**：这个线性序列被称为**拓扑有序序列**或**拓扑序列**。
    
- **唯一性**：一个AOV网的拓扑序列**可能不唯一**。
    
- **前提**：只有**有向无环图**才能进行拓扑排序。如果一个图中存在环，则无法生成拓扑序列。
    

### 3. 拓扑排序算法

#### 算法思想

该算法基于一个简单的思想：在有向图中，入度为0的顶点是没有任何前置依赖的，可以作为序列的起点。

1. 从图中选择一个**入度为0**的顶点，并将其输出到拓扑序列中。
    
2. 从图中**删除**该顶点以及所有以它为起点的有向边。
    
3. 重复以上步骤，直到所有顶点都被输出。
    
4. 如果图中不存在入度为0的顶点，但仍有顶点未被输出，则说明图中**存在环**。
    

#### 数据结构设计

- **图的存储**：推荐使用**邻接表**。为了方便计算入度，可以在顶点表中增加一个`in-degree`（入度）域。
    
- **辅助数据结构**：使用一个**栈**或**队列**来存储所有入度为0的顶点。这两种结构都可以，使用栈或队列得到的拓扑序列可能不同，但都是有效的。
    

#### 算法伪代码

```c
function TopologicalSort(Graph G):
  // 1. 初始化
  Initialize an empty list `result` for the topological sequence
  Initialize a queue (or stack) `S`
  Calculate the in-degree for every vertex in G

  // 2. 将所有入度为0的顶点入队/入栈
  For each vertex `u` in G:
    if in-degree[u] == 0:
      S.push(u)

  // 3. 主循环
  while S is not empty:
    u = S.pop()
    add `u` to `result`

    // 4. 更新与u相邻顶点的入度
    For each neighbor `v` of `u`:
      in-degree[v] = in-degree[v] - 1
      if in-degree[v] == 0:
        S.push(v)

  // 5. 检查是否存在环
  if length of `result` == number of vertices in G:
    return `result`
  else:
    return "Error: Graph has a cycle"
```

## 三、关键路径（Critical Path）

### 1. AOE网（Activity on Edge Network）

当我们需要分析工程的耗时和关键任务时，通常使用AOE网。

- **定义**：AOE网是一个带权的**有向无环图**，其中：
    
    - **有向边（Edge）**：代表一个**活动（Activity）**。
        
    - **边的权值**：表示该活动持续的**时间（Duration）**。
        
    - **顶点（Vertex）**：代表一个**事件（Event）**，表示某些活动的完成和另一些活动的开始。
        
- **源点（Source）**：没有入边的顶点，表示整个工程的开始。
    
- **汇点（Sink）**：没有出边的顶点，表示整个工程的结束。
    

### 2. 关键路径的定义

- **路径长度**：从源点到汇点的某条路径上所有活动持续时间之和。
    
- **关键路径**：在一个AOE网中，从源点到汇点的所有路径中，**长度最长**的那条路径。
    
- **工程总工期**：关键路径的长度决定了完成整个工程所需的**最短时间**。
    
- **关键活动**：关键路径上的所有活动都称为**关键活动**。任何一个关键活动的延迟都会导致整个工程的工期延长。
    

### 3. 关键路径算法

为了找到关键路径，我们需要计算以下几个核心参数：

#### a. 事件的最早发生时间 `ve(j)` (vertex earliest)

- **定义**：事件`j`能够发生的最早时刻。它等于从源点到顶点`j`的**最长路径**的长度。
    
- **计算公式**：
    
    - `ve(源点) = 0`
        
    - `ve(k) = max{ ve(j) + duration(<j, k>) }`，其中 `<j, k>` 是所有以 `k` 为终点的活动。
        
- **计算顺序**：按照**拓扑有序**的顺序，从前往后计算。
    

#### b. 事件的最迟发生时间 `vl(j)` (vertex latest)

- **定义**：在不推迟整个工程工期的前提下，事件`j`必须发生的最晚时刻。
    
- **计算公式**：
    
    - `vl(汇点) = ve(汇点)` （即整个工程的最短完成时间）
        
    - `vl(j) = min{ vl(k) - duration(<j, k>) }`，其中 `<j, k>` 是所有以 `j` 为起点的活动。
        
- **计算顺序**：按照**拓扑逆序**的顺序，从后往前计算。
    

#### c. 活动的最早开始时间 `e(i)` (edge earliest)

- **定义**：对于活动 `a_i = <j, k>`，其能开始的最早时刻。
    
- **计算公式**：取决于其起始事件`j`的最早发生时间。
    
    - `e(i) = ve(j)`
        

#### d. 活动的最晚开始时间 `l(i)` (edge latest)

- **定义**：在不推迟整个工程工期的前提下，活动`a_i`必须开始的最晚时刻。
    
- **计算公式**：取决于其结束事件`k`的最迟发生时间。
    
    - `l(i) = vl(k) - duration(<j, k>)`
        

#### e. 确定关键活动

- **时间余量**：`slack(i) = l(i) - e(i)`。这个值表示一个活动可以延迟的时间，而不会影响总工期。
    
- **关键活动**：时间余量为**0**的活动，即 `l(i) = e(i)` 的活动。
    
- **关键路径**：所有关键活动连接起来构成的从源点到汇点的路径。
    

### 4. 算法实现步骤

1. **正向拓扑排序**：
    
    - 对AOE网进行拓扑排序。
        
    - 在此过程中，从源点开始，按拓扑顺序计算每个事件的**最早发生时间 `ve`**。
        
    - 同时，将拓扑序列压入一个栈中，以备后续逆序使用。
        
2. **反向拓扑排序**：
    
    - 从栈中依次弹出顶点（这将得到一个拓扑逆序）。
        
    - 从汇点开始，按拓扑逆序计算每个事件的**最迟发生时间 `vl`**。
        
3. **计算活动的 `e` 和 `l`**：
    
    - 遍历图中的每一条边（每一个活动）。
        
    - 根据公式计算每个活动的**最早开始时间 `e`** 和 **最晚开始时间 `l`**。
        
4. **找出关键路径**：
    
    - 再次遍历所有活动，如果一个活动的 `e` 和 `l` 相等，则该活动为关键活动，其所在的路径即为关键路径的一部分。