哈希索引的本质是：用数学函数把“任意数据”映射成“固定范围的整数”，再用这个整数作为数组下标直接定位数据，从而避免遍历。

---

## ✅ 一句话原理  

> 通过哈希函数将键（key）映射到数组的某个槽位（bucket），实现“一次计算，直接定位”的查找。

---

## 🔍 逐步拆解原理

1. 哈希函数（Hash Function）
- 输入：任意类型（字符串、整数、对象等）。
- 输出：一个整数（称为哈希值或哈希码）。
- **三大特点**：
	- **确定性**：相同的输入必然会产生相同的输出。
    - **分布性**：不同的输入应产生尽量均匀分布的哈希值，以最大限度地减少碰撞（多个不同键得到相同哈希值）的概率。
    - **高效性**：函数的计算速度必须非常快，时间复杂度为 O(1)。

示例（Python 内置哈希）：

```python
hash("apple")   # 输出：例如 1546867648（取决于实现）
```

---

## 2 . 数组槽位定位（Bucket Index）
- 将哈希值对数组长度取模，得到槽位索引：

```
index = hash(key) % array_length
```
这里 `%` 是取模运算符，它能确保无论哈希值多大，计算出的 `index` 始终在 `0` 到 `array_length - 1` 的范围内。
- **存储结构**：数组的每一个槽位（bucket）本身通常是一个指针，指向一个数据结构（如链表或红黑树），用于存储所有映射到此槽位的键值对，以此来处理潜在的哈希碰撞。

---

## 3 . 插入与查找
- **插入数据**：
    1. 计算键（key）的哈希值，并通过取模运算得到目标槽位索引 `index`。
        
    2. 访问该 `index` 对应的槽位。如果槽位为空，则直接插入新数据。
        
    3. 如果槽位已被占用（即发生碰撞），则将新数据追加到该槽位已有的链表或红黑树的末端。
        
- **查找数据**：
    1. 同样计算待查键（key）的 `index`。
        
    2. 直接访问 `index` 对应的槽位。
        
    3. 遍历该槽位上的链表或红黑树，逐个比对每个元素的键，直到找到与待查键完全匹配的元素。

---

## 4 . 碰撞处理（Collision Resolution）
当不同的键映射到同一个槽位时，就需要碰撞处理机制。
- 链地址法（Python `set` / `dict` 使用）：
	这是Python的字典（`dict`）和集合（`set`）所采用的方法。它为数组的每个槽位都维护一个独立的链表或红黑树。所有哈希值相同的键都会被存储在这同一个数据结构中。
- 开放寻址法：
	这是Java中 `HashMap` 使用的一种策略。如果计算出的槽位已被占用，它会按照预定的规则（如线性探测）去寻找下一个可用的空槽位来存放数据。

---

## 🎯 性能关键
- 理想情况：
  哈希函数均匀分布，无碰撞 → 查找/插入/删除均为 O (1)。
- 最坏情况：
  所有键哈希到同一槽位 → 退化为链表遍历，O (n)（但通过红黑树优化为 O (log n)）。

---

## 📌 总结图示
- **输入键**：`"apple"`。
    
- **哈希计算**：键通过哈希函数，得到一个整数 `1546867648`。
    
- **定位槽位**：将哈希值对数组长度取模，得到最终的数组索引，例如 `8`。
    
- **访问与查找**：程序访问数组索引为 `8` 的位置，找到对应的链表头。随后遍历此链表，确认链表中是否存在键为 `"apple"` 的节点。

---

## 🧠 一句话记忆

> 哈希索引 = 数学映射（哈希函数） + 数组随机访问 + 碰撞处理机制。