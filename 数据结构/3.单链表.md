## 一、 线性链表基础

### 1.1 链式存储结构特点

线性表的链式存储结构，通常称为线性链表或链表，其核心思想是打破物理地址必须连续的限制。

- **存储单元**：用一组任意的存储单元来存储线性表的各个数据元素。

- **逻辑与物理**：通过指针实现逻辑上相邻的元素在物理上可以不相邻。

- **结点构成**：每个数据元素除了存储自身信息（数据域）外，还必须存储其直接后继的地址信息（指针域）。

### 1.2 链表定义与分类

- **定义**：采用链式存储结构的线性表称为链表。

- **分类**：
  
  1. **从实现角度**：可分为动态链表（常用，在程序运行时按需分配空间）和静态链表（使用数组模拟）。
  
  2. **从链接方式角度**：可分为单链表、循环链表和双链表。

### 1.3 单链表结构

单链表是结点中只包含一个指向直接后继的指针域的链表。

#### 1.3.1 结点 (Node)

每个结点包含两个部分：

- **数据域 (data)**：用于存储元素本身的信息。

- **指针域 (next)**：用于存储其直接后继结点的内存地址。

#### 1.3.2 头指针 (Head Pointer) 与 头结点 (Head Node)

- **头指针 (Head Pointer)**：是一个指向链表中第一个结点的指针。对于一个非空链表，头指针 `head` 指向第一个数据元素所在的结点。

- **头结点 (Head Node)**：为了操作方便，通常在第一个元素结点之前附加一个结点，称为头结点。
  
  - **数据域**：可以不存储任何信息，也可以存储如链表长度等附加信息。
  
  - **指针域**：指向第一个元素结点。
  
  - **优点**：
    
    1. 使对第一个元素结点的插入、删除操作与对其他结点的操作相统一，无需特殊处理。
    
    2. 无论链表是否为空，头指针都指向头结点，使得空表和非空表的处理逻辑一致。空表即头结点的指针域为`NULL`。

## 二、 单链表的C语言实现

### 2.1 结构体定义

在C语言中，我们使用结构体来定义单链表的结点类型。

```C
typedef struct Node {
    ElemType data;       // 数据域
    struct Node *next;   // 指针域
} Node, *LinkList;       // Node是结构体类型名，LinkList是指向Node的指针类型
```

- `ElemType` 为数据元素的类型，可根据实际需求定义，如 `int`, `char` 等。

- `LinkList L;` 等价于 `Node *L;`，`L` 是一个指向链表结点的指针。

### 2.2 初始化

初始化操作是构造一个带头结点的空链表。

```C
// 初始化一个带头结点的空链表
void InitList(LinkList *L) {
    // 1. 生成新结点作为头结点
    *L = (LinkList)malloc(sizeof(Node));
    if (!(*L)) { // 内存分配失败处理
        exit(OVERFLOW);
    }
    // 2. 头结点的指针域置空
    (*L)->next = NULL;
}
```

> **注意**：这里的函数参数是 `LinkList *L`，即二级指针。因为 `LinkList` 本身是 `Node *` 类型，我们需要在函数内部修改调用方传入的头指针 `L` 的值，所以必须传递 `L` 的地址（传址调用），这与 `swap` 函数交换两个变量的值需要传递指针是同样的道理。

## 三、 单链表的基本操作 (含算法实现)

### 3.1 创建单链表

#### 3.1.1 头插法

**思想**：从一个空表开始，每次生成一个新结点，将数据存入后，将该新结点插入到头结点之后、原第一个结点之前。 这种方法建立的链表，其元素的逻辑顺序与输入顺序**相反**。

**算法实现**：

```C
// 头插法建立单链表 (输入'$'结束)
void CreateFromHead(LinkList L) {
    Node *s;
    char c;
    while ((c = getchar()) != '$') {
        // 创建新结点
        s = (Node*)malloc(sizeof(Node));
        s->data = c;
        // 插入到头结点后
        s->next = L->next;
        L->next = s;
    }
}
```

#### 3.1.2 尾插法

**思想**：始终保持一个尾指针 `r` 指向链表的最后一个结点。每次生成新结点并存入数据后，将其链接到 `r` 的后面，然后更新 `r` 指向这个新的尾结点。 这种方法建立的链表，其元素的逻辑顺序与输入顺序

**相同**。

**算法实现**：

```C
// 尾插法建立单链表 (输入'$'结束)
void CreateFromTail(LinkList L) {
    Node *s, *r;
    char c;
    r = L; // r 初始时指向头结点
    while ((c = getchar()) != '$') {
        // 创建新结点
        s = (Node*)malloc(sizeof(Node));
        s->data = c;
        // 链接到尾部并更新尾指针
        r->next = s;
        r = s;
    }
    r->next = NULL; // 建立完成后，将尾结点的指针域置空
}
```

### 3.2 查找操作 (按值查找)

**思想**：从链表的第一个元素结点开始，顺着指针域 `next` 依次向后遍历，比较每个结点数据域的值是否与目标值 `key` 相等。如果找到，返回该结点的指针；如果遍历到链表末尾仍未找到，返回 `NULL`。

**算法实现**：

```C
// 在带头结点的单链表L中查找值为key的结点
Node *Locate(LinkList L, ElemType key) {
    Node *p = L->next; // p指向第一个元素结点
    while (p != NULL && p->data != key) {
        p = p->next;
    }
    return p; // 找到则返回p，否则p为NULL
}
```

**时间复杂度**：O(n)

### 3.3 插入操作

**思想**：在第 `i` 个位置插入一个新结点，需要以下三步：

1. 找到第 `i-1` 个结点，用指针 `pre` 指向它。

2. 生成一个值为`e` 的新结点 `s`。

3. 修改指针，将`s` 插入到 `pre` 之后、原第 `i` 个结点之前。即：`s->next = pre->next; pre->next = s;` 19

**算法实现**：

```C
// 在带头结点的单链表L中第i个位置插入元素e
void InsList(LinkList L, int i, ElemType e) {
    Node *pre = L;
    int k = 0;
    // 1. 查找第 i-1 个结点
    while (pre != NULL && k < i - 1) {
        pre = pre->next;
        k++;
    }
    // 检查位置的合法性
    if (pre == NULL || k != i - 1) {
        printf("插入位置不合理！\n");
        return;
    }
    // 2. 创建新结点
    Node *s = (Node*)malloc(sizeof(Node));
    s->data = e;
    // 3. 插入
    s->next = pre->next;
    pre->next = s;
}
```

**时间复杂度**：查找第 `i-1` 个结点的时间为 O(i)，插入本身为 O(1)，总复杂度为 O(n)。

### 3.4 删除操作

**思想**：删除第 `i` 个位置的结点，需要以下两步：

1. 找到第`i-1` 个结点，用指针 `p` 指向它。

2. 用一个临时指针 `r` 指向要删除的第 `i` 个结点 (`r = p->next;`)。

3. 将`p` 的指针域直接指向第 `i+1` 个结点 (`p->next = r->next;`)，从而将第 `i` 个结点从链中断开。

4. 释放被删除结点`r` 的内存空间 (`free(r);`)。

**算法实现**：

```C
// 在带头结点的单链表L中删除第i个元素，并用e返回其值
int DelList(LinkList L, int i, ElemType *e) {
    Node *p = L;
    int k = 0;
    // 1. 查找第 i-1 个结点
    while (p->next != NULL && k < i - 1) {
        p = p->next;
        k++;
    }
    // 检查位置的合法性
    if (p->next == NULL || k != i - 1) {
        printf("删除位置不合理！\n");
        return 0; // 失败返回0
    }
    // 2. 删除并释放结点
    Node *r = p->next;
    *e = r->data; // 保存被删除结点的值
    p->next = r->next;
    free(r);
    return 1; // 成功返回1
}
```

**时间复杂度**：查找第 `i-1` 个结点的时间为 O(i)，删除本身为 O(1)，总复杂度为 O(n)。

### 3.5 求表长操作

**思想**：从第一个元素结点开始，遍历整个链表，用一个计数器 `j` 记录经过的结点数，直到链表末尾。

**算法实现**：

```C
// 求单链表的长度
int ListLength(LinkList L) {
    Node *p = L->next;
    int j = 0;
    while (p != NULL) {
        j++;
        p = p->next;
    }
    return j;
}
```

**时间复杂度**：O(n)

## 四、 单链表的应用

### 4.1 求两个集合的差 (A-B)

问题：已知集合A和B分别用单链表LA和LB表示，求差集 A-B。

**算法思想**：遍历集合A（链表LA）的每个元素，对于A中的每个元素 `p->data`，都去集合B（链表LB）中查找。如果在LB中找到了相同的元素，就将该元素从LA中删除。

**算法实现**：

```C
// 求差集 LA = LA - LB
void Difference(LinkList LA, LinkList LB) {
    Node *pre = LA, *p = LA->next;
    Node *q, *r;

    while (p != NULL) {
        q = LB->next;
        // 在LB中查找是否存在与p->data相同的元素
        while (q != NULL && q->data != p->data) {
            q = q->next;
        }

        if (q != NULL) { // 在LB中找到了，需要从LA中删除*p
            r = p;
            pre->next = p->next;
            p = p->next;
            free(r);
        } else { // 在LB中未找到，继续考察LA的下一个元素
            pre = p;
            p = p->next;
        }
    }
}
```

### 4.2 合并两个有序单链表

**问题**：已知单链表LA和LB中的元素按值非递减有序排列，将它们合并成一个新的有序单链表LC。

算法思想：

1. 创建一个新的头结点LC。使用两个指针 `pa` 和 `pb` 分别指向LA和LB的第一个元素结点。

2. 比较 `pa->data` 和 `pb->data` 的大小，将较小的结点链接到LC的末尾。

3. 移动较小结点所在链表的指针（`pa` 或 `pb`）和LC的尾指针。

4. 重复步骤2和3，直到一个链表为空。

5. 将另一个不为空的链表的剩余部分直接链接到LC的末尾。

**算法实现** (采用原地合并，将LB合并到LA中，并返回合并后的头指针LA作为LC)：

```C
LinkList MergeLinkList(LinkList LA, LinkList LB) {
    Node *pa = LA->next;
    Node *pb = LB->next;
    Node *r; // r 始终指向LC的尾结点

    LinkList LC = LA; // 用LA的头结点作为LC的头结点
    LC->next = NULL;
    r = LC;

    // 比较并链接
    while (pa != NULL && pb != NULL) {
        if (pa->data <= pb->data) {
            r->next = pa;
            r = pa;
            pa = pa->next;
        } else {
            r->next = pb;
            r = pb;
            pb = pb->next;
        }
    }

    // 连接剩余部分
    if (pa != NULL) {
        r->next = pa;
    } else {
        r->next = pb;
    }

    free(LB); // 释放LB的头结点
    return LC;
}
```

## 五、 顺序表与链表对比总结

| 比较维度      | 顺序表 (Sequential List)    | 链表 (Linked List)              |     |
| --------- | ------------------------ | ----------------------------- | --- |
| **存储方式**  | 占用一片**连续**的存储单元          | 占用**任意** (不连续) 的存储单元          |     |
| **存取方式**  | **随机存取** ( O(1) )        | **顺序存取** ( O(n) )             |     |
| **插入/删除** | 平均移动近一半元素，时间复杂度O(n)      | 只需修改指针，时间复杂度O(1) (若不计查找前驱的时间) |     |
| **空间分配**  | 静态分配或一次性动态分配，可能造成空间浪费或溢出 | 按需动态分配，空间利用率高                 |     |

## 六、 课堂小测

**单选题**：下面关于线性表的叙述中，错误的是（ D ）。

A. 顺序表必须占用一片地址连续的存储单元

B. 链表不必占用一片地址连续的存储单元

C. 顺序表可以随机存取任一元素

D. 链表可以随机存取任一元素

**解析**：链表由于其非连续的存储结构，访问某个特定元素必须从头开始依次向后查找，因此只能进行顺序存取，不能随机存取。所以选项D是错误的。