## 一、串的定义 (String Definition)

### 1. 基本概念

- **串 (String)**：是由零个或多个字符组成的有限序列。可以看作是一种特殊的线性表，其数据元素限定为字符。
    
- **一般表示**：通常记为 $S=''a_0a_1a_2...a_{n−1}''$，其中 $n\ge0$ 。
    
- **字符集**：串中的字符可以是字母、数字或其他任何符号，具体取决于计算机系统所支持的字符集 。
    
- **串的长度**：串中包含的字符个数，记为 n 。
    
- **应用**：串在信息处理领域应用广泛，如文本编辑、事务处理中的客户信息（姓名、地址）、生物信息学中的DNA序列分析等 。
    

### 2. 相关术语

- **空串 (Empty String)**：长度为0的串，记作 `''''` 。它不包含任何字符。
    
- **空格串 (Blank String)**：仅由一个或多个空格字符组成的串。注意，空格串的长度不为0。
    
- **子串 (Substring)**：串中任意个连续的字符组成的子序列。例如，`''string''` 是 `''This is a string''` 的子串 。
    
- **主串 (Main String)**：包含子串的那个串被称为主串 。
    
- **串相等**：两个串当且仅当它们的长度相等，并且对应位置的字符也都相同时，才称这两个串相等 。
    
    - 若 $S_1=''a_1a_2...a_n''$ 且 $S_2=''b_1b_2...b_m''$，则 $S_1=S_2$ 的条件是：n=m 且对于所有 i ($1\le{i\le n}$)，都有 $a_i=b_i$。

## 二、串的存储与实现

### 1. 顺序存储 (Sequential Storage)

串可以采用**静态数组**的方式进行顺序存储，这通常被称为**顺序串**。

- **结构定义**：使用一个定长字符数组存储串的字符序列，并用一个整型变量记录串的当前长度。
    
    ```c
    #define MAXLEN 40 // 预定义最大串长
    typedef struct {
        char ch[MAXLEN]; // 存储串的字符数组
        int len;         // 记录串的当前长度（便于删除&更新数据）
    } SString;
    ```
### 2. 堆存储 (Heap Storage)

为了克服顺序存储中固定长度的限制，可以采用动态分配内存的方式，这被称为**堆串**。

- **概念**：串的字符序列存储在程序执行过程中动态分配的内存区域（堆）中。这种方式可以根据字符串的实际需要分配空间，更加灵活 。
    
- **结构定义**：通常使用一个**字符指针**指向动态分配的起始内存地址，并用一个整型变量记录其长度。
    
    ```cpp
    typedef struct {
        char *ch; // 指向串的起始地址的指针
        int len;  // 串的长度
    } HString;
    ```

### 3. 块链存储 (Block-chain Storage)

当字符串非常长时，可以采用链式存储结构，每个节点存放一个数据块，这被称为**块链串**。

- **概念**：将串的字符序列存储在若干个通过指针链接起来的存储块中。
    
- **结构定义**：
    
    ```cpp
    #define BLOCK_SIZE 4 // 每个结点存放的字符个数
    typedef struct Block {
        char ch[BLOCK_SIZE];
        struct Block *next;
    } Block;
    
    typedef struct {
        Block *head;    // 指向链表头
        Block *tail;    // 指向链表尾
        int length;     // 串的总长度
    } BLString;
    ```


## 三、串的基本操作实现

### 1. 顺序串操作

- **删除子串 `StrDelete`**
    
    ```cpp
    /*
     * 在串s中删除从下标pos开始，长度为len的子串
     */
    int StrDelete(SString *s, int pos, int len) {
        // 参数检查：pos和len的合法性
        if (pos < 0 || pos > (s->len - len)) {
            return 0; // 删除位置不合法
        }
    
        // 将pos+len后的字符前移
        for (int i = pos + len; i < s->len; i++) {
            s->ch[i - len] = s->ch[i];
        }
    
        // 更新串长
        s->len = s->len - len;
        return 1; // 删除成功
    }
    ```
- **比较串 `StrCompare`**（字典序比较）
    
    ```cpp
    /*
     * 比较串s和串t的大小
     * 若s > t，返回正数; s < t，返回负数; s == t，返回0
     */
    int StrCompare(SString s, SString t) {
        // 逐个字符比较
        for (int i = 0; i < s.len && i < t.len; i++) {
            if (s.ch[i] != t.ch[i]) {
                return (s.ch[i] - t.ch[i]); // 返回第一个不同字符的差值
            }
        }
        // 若较短的串是较长串的前缀，则根据长度判断大小
        return (s.len - t.len);
    }
    ```
### 2. 堆串操作

- **赋值操作 `StrAssign`**
    
    ```cpp
    /*
     * 将字符常量tval的值赋给堆串s
     */
    int StrAssign(HString *s, char *tval) {
        int len = 0, i = 0;
    
        // 如果s原来有值，释放旧空间
        if (s->ch != NULL) free(s->ch);
    
        // 计算tval的长度
        while (tval[i] != '\0') i++;
        len = i;
    
        if (len) {
            // 分配新空间
            s->ch = (char *)malloc(len);
            if (s->ch == NULL) return 0; // 分配失败
            // 复制字符
            for (i = 0; i < len; i++) s->ch[i] = tval[i];
        } else {
            s->ch = NULL; // 如果是空串
        }
    
        s->len = len;
        return 1;
    }
    ```

- **插入操作 `StrInsert`**
    
    ```c
    /*
     * 在串s中下标为pos的字符之前插入串t
     */
    int StrInsert(HString *s, int pos, HString *t) {
        if (pos < 0 || pos > s->len) return 0; // 插入位置不正确
    
        // 重新分配足以容纳两个串的总空间
        char *temp = (char *)malloc(s->len + t->len);
        if (temp == NULL) return 0; // 分配失败
    
        // 复制s中pos之前的部分
        for (int i = 0; i < pos; i++) temp[i] = s->ch[i];
        // 复制t的全部内容
        for (int i = 0; i < t->len; i++) temp[i + pos] = t->ch[i];
        // 复制s中pos之后的部分
        for (int i = pos; i < s->len; i++) temp[i + t->len] = s->ch[i];
    
        s->len += t->len;
        free(s->ch);  // 释放原来的旧空间
        s->ch = temp; // 指向新空间
        return 1;
    }
    ```
    
- **删除操作 `StrDelete`**
    
    ```c
    /*
     * 在串s中删除从下标pos起len个字符
     */
    int StrDelete(HString *s, int pos, int len) {
        if (pos < 0 || pos > (s->len - len)) return 0; // 删除位置不正确
    
        // 分配一个更小的空间来存放删除后的结果
        char *temp = (char *)malloc(s->len - len);
        if (temp == NULL) return 0; // 分配失败
    
        // 复制需要保留的第一部分
        for (int i = 0; i < pos; i++) temp[i] = s->ch[i];
        // 复制需要保留的第二部分
        for (int i = pos; i < s->len - len; i++) temp[i] = s->ch[i + len];
    
        s->len -= len;
        free(s->ch);  // 释放原来的旧空间
        s->ch = temp; // 指向新空间
        return 1;
    }
    ```
## 四、串的模式匹配 (Pattern Matching)

模式匹配是在主串（目标串 T）中查找是否存在与模式串（子串 P）相同的子串，并确定其位置的过程 。

### 1. 简单模式匹配算法 (Brute-Force)

- **思想**：从主串的指定位置开始，将主串与模式串逐个字符进行比较。若不匹配，则主串的比较指针回溯到下一个起始位置，模式串指针回到开头，重新进行下一趟比较 。
    
- **过程**：
    
    1. 设主串指针 `i` 和模式串指针 `j`。
        
    2. `i` 从主串的起始位置 `pos` 开始，`j` 从 0 开始。
        
    3. 当`T[i] == P[j]` 时，同时递增 `i` 和 `j`，继续比较后续字符 。
        
    4. 当`T[i] != P[j]` 时，发生失配。主串指针 `i` 回溯到 `i - j + 1`，模式串指针 `j` 回到 0，开始新一轮匹配 。
        
    5. 重复此过程，直到`j` 越界 (等于模式串长度)，表示匹配成功 ；或者`i` 越界 (等于主串长度)，表示匹配失败 。
        
- **代码实现**：
    
    ```cpp
    int SimpleIndex(SString T, SString P, int pos) {
        int i = pos; // 主串指针
        int j = 0;   // 模式串指针
    
        while (i < T.len && j < P.len) {
            if (T.ch[i] == P.ch[j]) {
                // 字符匹配，继续比较
                i++;
                j++;
            } else {
                // 字符失配，指针回溯
                i = i - j + 1;
                j = 0;
            }
        }
    
        if (j == P.len) {
            return i - j; // 匹配成功，返回起始下标
        } else {
            return -1; // 匹配失败
        }
    }
    ```
    
- **复杂度分析**：
    
    - 设主串长度为 n，模式串长度为 m。
        
    - **最好情况**：第一趟就匹配成功，时间复杂度为 O(m) 。
        
    - **最坏情况**：每次都在模式串的最后一个字符处才发现不匹配（例如 T=''00...01'', P=''0...01''），需要进行 n−m+1 趟匹配，每趟比较 m 次。时间复杂度为 O($n\times m$) 。
### 2. 首尾字符串模式匹配算法

- **思想**：这是对简单匹配的一种改进思路，它尝试从模式串的**首尾两端同时向中间**进行比较。如果首尾字符都匹配，再向中间收缩比较范围。这种方式在某些情况下（如不匹配发生在模式串两端）可能更快发现失配。
    
- **过程**：
    
    1. 外层循环控制主串的起始匹配点 `startPos`。
        
    2. 内层循环设置两个指针，`front` 指向模式串开头，`rear` 指向模式串末尾。
        
    3. 在内层循环中，同时检查 `T[startPos + front]` 与 `P[front]` 以及 `T[startPos + rear]` 与 `P[rear]` 是否相等。
        
    4. 一旦有任何一对不匹配，就立即跳出内层循环，主串的起始点 `startPos` 后移一位，开始下一趟匹配。
        
    5. 如果 `front` 越过 `rear`，说明模式串中的所有字符都已从两端向内匹配成功。
        
- **代码实现**：
    
    ```c
    int FrontRearIndex(SString T, SString P, int pos) {
        int startPos = pos;
        while (startPos <= T.len - P.len) {
            int front = 0, rear = P.len - 1;
            while (front <= rear) {
                // 从首尾同时比较
                if (T.ch[startPos + front] != P.ch[front] || T.ch[startPos + rear] != P.ch[rear]) {
                    break; // 任何一端不匹配则失败
                } else {
                    front++;
                    rear--;
                }
            }
            if (front > rear) {
                return startPos; // 匹配成功
            } else {
                startPos++; // 否则主串指针后移，开始下一趟
            }
        }
        return -1; // 匹配失败
    }
    ```
    
- **评价**：这种算法的思路很巧妙，但在不匹配发生在模式串中间位置时，其效率可能反而会比简单算法更低。
### 3. KMP算法

KMP算法是对简单模式匹配算法的重大改进，其核心思想是:

**在发生失配时，主串指针 `i` 不需要回溯**，而是利用已经匹配过的信息，将模式串 `P` 向右“滑动”到一个合适的位置，从而提高效率 。

- **核心：`next` 数组**
    
    - `next` 数组（或称“部分匹配表”）是根据模式串自身结构预先计算好的一个数组 。
        
    - `next[j]` 的值表示当模式串的第 `j` 个字符 `P[j]` 与主串字符发生失配时，模式串的比较指针 `j` 应该回溯到的新位置。
        
    - **`next[j]` 的计算**：`next[j]` 的值等于模式串 `P` 的子串 $P_0...P_{j-1}$的 **最长公共前后缀 (LPS) 的长度**。
        
        - **前缀**：指除了最后一个字符以外，一个字符串的全部头部组合 。
            
        - **后缀**：指除了第一个字符以外，一个字符串的全部尾部组合 。
            
        - **例**：对于模式串 `''ABCDABD''`，其子串 `''ABCDAB''` 的前缀有 `{''A'', ''AB'', ''ABC'', ''ABCD'', ''ABCDA''}`，后缀有 `{''B'', ''AB'', ''DAB'', ''CDAB'', ''BCDAB''}`。公共前后缀为 `''AB''`，长度为2。
          因此，当 `P[6]` ('D') 失配时，`next[6]` 的值（对应于''ABCDAB''的部分匹配值）为2 。
            
    - **`next` 数组的定义** ：
    $$
\text{next}[j] = 
\begin{cases} 
-1 & \text{当 } j=0 \text{ 时} \\
\max\{ k \mid 0 < k < j \text{ 且 } "P_0...P_{k-1}" = "P_{j-k}...P_{j-1}" \} & \text{当此集合不空时} \\
0 & \text{其他情况} 
\end{cases}
$$
- **KMP算法流程**：
    
    1. 预先计算模式串 `P` 的 `next` 数组。
        
    2. 初始化主串指针 `i=0`，模式串指针 `j=0`。
        
    3. `while (i < T.len && j < P.len)`:
        
        - 如果
            
            `j == -1` (表示从头开始匹配) 或 `T[i] == P[j]`，则 `i++`, `j++` 。
            
        - 如果
            
            `T[i] != P[j]` (失配)，则主串指针 `i` **保持不变**，模式串指针 `j` 更新为 `next[j]` 。
            
    4. 循环结束后，若
        
        `j == P.len`，则匹配成功，返回起始位置 `i-j` 。否则匹配失败 。

- **`KMP算法`**
	
```c
int KMP(char *t,char *p)
{
int i = -1;//主串
int j = -1;//子串
while (i<(int)strlen(t) && j<(int)strlen(p))
	{
	if(j==-1||t[i]==p[j])
		{i++;j++;}
		else j=next[j];
	}
	if(j==strlen(p))
		return i-j;
		else return -1;
}
``` 
- **`getNext` 数组生成算法**
    
    ```cpp
    void getNext(char* p, int* next) {
        int p_len = strlen(p);
        next[0] = -1;
        int i = 0;   // 后缀指针
        int j = -1;  // 前缀指针
    
        while (i < p_len - 1) { // 注意循环条件
            if (j == -1 || p[i] == p[j]) {
                ++i;
                ++j;
                next[i] = j;
            } else {
                j = next[j]; // 回溯
            }
        }
    }
    ```
    
- **复杂度分析**：
    
    - `getNext` 函数的时间复杂度为 O(m)。
        
    - KMP匹配过程的时间复杂度为 O(n)。
        
    - 总体时间复杂度为
        
        O(n+m)，远优于简单匹配算法 。
        

### 4. Rabin-Karp 算法

- **思想**：利用哈希函数（Hash Function）将字符串转换为一个整数值。比较时，不直接比较字符串，而是先比较它们的哈希值 。
    
- **过程**：
    
    1. 计算模式串 `P` 的哈希值 $hash_P$。
        
    2. 计算主串 `T` 中第一个长度为 `m` 的子串的哈希值 $hash_T$。
        
    3. 循环比较 $hash_P$ 和 $hash_T$：
        
        - 如果哈希值不相等，则通过高效的“滚动哈希”方法计算主串中下一个子串的哈希值。
            
        - 如果哈希值相等，由于可能存在**哈希冲突**（不同的字符串有相同的哈希值），需要再进行一次朴素的逐字符比较来确认是否真正匹配 。
            
    4. 重复此过程直到找到匹配或遍历完主串。
        
- **补充知识**：*滚动哈希*是该算法的关键，它允许在 O(1) 的时间内计算出下一个子串的哈希值，而不是重新以 O(m) 的时间计算。
## 五、串的应用举例：文本编辑

串作为一种基本的数据结构，在文本编辑器等软件中有着非常直观和重要的应用。我们可以将一篇完整的文本当作一个巨大的字符串来处理。

- **层次化结构**：一篇文本文档可以被看作一个**文本串**。通过分页符和换行符，这个大字符串可以被自然地划分为若干**页**，而每一页又可以被划分为若干**行**。这样，页就是文本串的子串，行则是页的子串。
    
- **存储与管理**：可以采用堆存储结构来存放整个文本内容。为了高效地进行查找、修改和显示，系统通常会建立**页表**和**行表**。这些表中记录了每一页、每一行的起始存储位置和各自的长度信息。当用户进行编辑操作时，程序通过维护当前光标所在的页、行、字符指针，并查询页表和行表，就能快速定位到需要操作的数据位置。

---