## 一、队列的定义 (Definition of Queue)

队列是一种特殊的线性表，其操作受到限制。

- **定义**: 队列是一个只允许在表的一端进行插入操作，而在另一端进行删除操作的线性表。 
    
- **队头 (Front)**: 允许删除元素的一端。 
    
- **队尾 (Rear)**: 允许插入元素的一端。 
    
- **核心特点**: **先进先出 (First-In, First-Out, FIFO)**。这个特性意味着最早进入队列的元素将最先被移出，类似于现实生活中的排队。 
    

_上图展示了队列的基本操作模型：元素从队尾进入（入队列），从队头离开（出队列）。_

---

## 二、队列的基本操作

以下是队列ADT（抽象数据类型）中定义的核心操作：

1. **`InitQueue(Q)`**: 初始化操作。
    
    - **初始条件**: 队列Q未被初始化。 
        
    - **操作结果**: 创建一个空的队列Q。 
        
2. **`IsEmpty(Q)`**: 判空操作。
    
    - **初始条件**: 队列Q已存在。 
        
    - **操作结果**: 如果队列为空，返回`true`；否则返回`false`。 
        
3. **`IsFull(Q)`**: 判满操作（主要用于顺序队列）。
    
    - **初始条件**: 队列Q已存在。 
        
    - **操作结果**: 如果队列已满，返回`true`。 
        
4. **`DeleteQueue(Q, x)`** (出队/出队列):
    
    - **初始条件**: 队列Q非空。 
        
    - **操作结果**: 删除队头元素，并用变量`x`返回该元素的值。 
        
5. **`GetHead(Q, x)`**: 获取队头元素。
    
    - **初始条件**: 队列Q非空。 
        
    - **操作结果**: 用变量`x`返回队头元素的值，但不出队。 
        
6. **`EnterQueue(Q, x)`** (入队/入队列):
    
    - **初始条件**: 队列Q已存在（且对于顺序队列，队列未满）。 
        
    - **操作结果**: 将元素`x`插入到队列中，成为新的队尾元素。 
        
7. **`ClearQueue(Q)`**: 清空队列。
    
    - **初始条件**: 队列Q已存在。 
        
    - **操作结果**: 将队列Q置为空队列。 
        

---

## 三、队列的存储结构

队列主要有两种物理存储结构：链式存储和顺序存储。

### 1. 链队列 (Linked Queue)

链队列是基于链表实现的队列。

- **结构**: 通常使用带头尾指针的链表。`front`指针指向链表的头部（队头），`rear`指针指向链表的尾部（队尾）。 
    
- **优点**: 入队操作没有空间限制（只要内存允许），不会出现“队满”的问题。 
    
- **队空条件**: 当 `front == rear` 时，队列为空。 
    

**定义示例:**

```c
typedef struct Node { // 队列节点定义
    QueueElementType data;
    struct Node *next;
} LinkQueueNode; 

typedef struct { // 链队列定义
    LinkQueueNode *front;
    LinkQueueNode *rear;
} LinkQueue;                   
```

### 2. 顺序队列 (Sequential Queue)

顺序队列是基于数组实现的队列。通过两个整型变量 `front` 和 `rear` 分别作为队头和队尾元素的**数组下标**。

- **入队**: `rear = rear + 1` 
    
- **出队**: `front = front + 1` 
    
- **问题**: 会出现 **“假溢出”** 现象。即数组尾部可能已经没有空间（`rear`到达数组末尾），但数组头部因为出队操作可能已经空出了许多位置。此时，虽然队列有空闲空间，但无法再进行入队操作。 
    

### 3. 循环队列 (Circular Queue)

为了解决顺序队列的“假溢出”问题，引入了循环队列。

- **思想**: 将数组的存储空间在逻辑上视为一个环形。当指针移动到数组的最后一个位置时，下一步会回到数组的起始位置。 
    
- **指针移动**: 使用取模（`%`）运算实现循环。 
    
    - 队头指针进1:
        
        $front = (front + 1) \% MAXSIZE;$
        
    - 队尾指针进1:
        
        $rear = (rear + 1) \% MAXSIZE;$
        
- **队空与队满的判断**:
    
    - **问题**: 在循环队列中，当队列为空时，$front == rear$ ；而当队列恰好填满所有空间时，
        
        `rear` 经过循环又会追上 `front`，导致 $front == rear$ 。这样就无法区分队空和队满状态。 
        
    - **解决方案**:
        
        1. 设置一个额外的标志位（`flag`）或一个计数器（`count`）来记录队列状态。 
            
        2. **牺牲一个存储单元**: 约定队头指针在队尾指针的下一个位置时，即为队满。这是更常用的方法。
            
- **采用“牺牲一个单元”方案的判断条件**:
    
    - **队列初始化**: $front = rear = 0;$
        
    - **队空条件**: $front == rear;$
        
    - **队满条件**: $(rear + 1) \% MAXSIZE == front;$
        
    - **队列长度**: $(rear - front + MAXSIZE) \% MAXSIZE;$
        

---

## 四、循环队列的实现 (C语言示例)

以下是基于“牺牲一个存储单元”方案的循环队列核心操作的C代码实现。

**结构定义:**
 ```c
#define MAXSIZE 
typedef struct {
    QueueElementType element[MAXSIZE]; 
    int front;
    int rear; 
} SeqQueue; 
```

**初始化:**

```c
void InitQueue(SeqQueue *Q) {
    Q->rear = Q->front = 0; 
}
```

**入队:**

```c
int EnterQueue(SeqQueue *Q, QueueElementType x) {
    // 判断队列是否已满
    if ((Q->rear + 1) % MAXSIZE == Q->front) { 
        return FALSE; // 队列已满，返回失败 
    }
    else {
        Q->element[Q->rear] = x; // 将元素x放入队尾 
        Q->rear = (Q->rear + 1) % MAXSIZE; // 队尾指针后移
        return TRUE; // 入队成功
    }
}
```

**出队:**

```c
int OutQueue(SeqQueue *Q, QueueElementType *x) {
    // 判断队列是否为空
    if (Q->rear == Q->front) { 
        return FALSE; // 队列为空，返回失败 
    }
    else {
        *x = Q->element[Q->front]; // 取出队头元素 
        Q->front = (Q->front + 1) % MAXSIZE; // 队头指针后移 
        return TRUE; // 出队成功 
    }
}
```

---

## 五、队列的应用

队列的“先进先出”特性使其在计算机科学中有广泛应用。

- **主要应用场景**:
    
    1. **解决主机与外设速度不匹配问题**: 如打印机队列，CPU将待打印文件快速送入队列后即可处理其他任务，打印机再从队列中慢慢取出文件打印。 
        
    2. **离散事件模拟**: 模拟现实世界中的各种**排队现象**，如银行客户排队、网络数据包排队等。 
        
    3. **处理具有先进先出特征的过程**: 例如广度优先搜索（BFS）算法([回溯法解迷宫](C:\Users\liuru\OneDrive\OneSyncFiles\obsidian\Runze\数据结构\Code\5.栈：回溯法.cpp))、操作系统中的进程调度等。 
        
- **应用示例1：显示二项式系数**
    
    - 问题: 计算并显示帕斯卡三角（杨辉三角），即 (a+b)n 的展开系数。
        
    - 规律: 第n行的系数可以由第 n−1 行的系数生成。除两端的1外，每个系数都是其上一行相邻两个数之和。 
        
    - 队列应用: 可以使用队列来存储上一行的系数。每次出队两个相邻元素 `s` 和 `t`，计算它们的和 `s+t` 并将其入队，同时将 `t` 再次入队，以便于下一次计算。
        
- **应用示例2：划分子集问题**
    
    - **问题描述**: 给定一个集合 A 和元素间的冲突关系 R，要求将 A 划分为最少数目的互不相交的子集，使得每个子集内的元素之间都没有冲突。 
        
    - **算法思想**: 利用**循环**筛选。 
        
        1. 将所有元素放入一个队列中。
            
        2. 开始一个新的分组（如第1组）。取出队头元素，它成为该组的第一个成员。
            
        3. 遍历队列中余下的所有元素：
            
            - 对于每个元素，判断它是否与当前组内已有的所有成员冲突。
                
            - 如果不冲突，则将其从队列中取出，加入当前组，并**更新**当前组的冲突信息。
	            - 根据具体的更新策略，程序会将元素 `x` 自身的冲突关系（矩阵 `r` 的第 `x` 行）**合并**到冲突信息 `newr` 中。具体操作是，`r[x]` 行为 `1` 的那些位置，在 `newr` 中也全部更新为 `1`。（这在逻辑上是一个“或”操作：`newr = newr OR r[x]`）。这样，`newr` 就变得更“严格”了，它现在代表了 `{e1, x, ...}` 这个集合的总体冲突情况。
                
            - 如果冲突，则将其留在队列中（通常是出队后再立即入队），以便参与下一轮分组。
                
        4. 当队列遍历一遍后，第1组形成。
            
        5. 对队列中剩下的元素重复以上步骤，形成第2组、第3组……直到队列为空。 
            

---

## 六、思考与练习

### 1. 简答题：用两个栈模拟一个队列

**题目**: 利用两个栈 $S_1$ 和 $S_2$ 模拟一个队列，如何实现队列的插入（入队）和删除（出队）运算？（北京理工大学2002年考题） 

**解答思想**: 

- **栈 S$_1$**: 作为输入栈。所有**入队**操作，直接将元素压入 $S_1$。
    
- **栈 $S_2$**: 作为输出栈。所有**出队**操作，都从 $S_2$ 弹出元素。
    
    - 如果 $S_2$ **不为空**，直接从 $S_2$ 栈顶弹出元素。
        
    - 如果 $S_2$ **为空**，则必须先将 $S_1$ 中的所有元素依次弹出，并立即压入 $S_2$ 中。这个过程会将 $S_1$ 中元素的顺序（后进先出）颠倒，放入 $S_2$ 后就变为了先进先出。操作完成后，再从 $S_2$ 栈顶弹出元素。
        
- **判空条件**: 当且仅当 $S_1$ 和 $S_2$ **同时为空**时，队列才为空。
    

### 2. 算法题：判断合法的出入栈序列

**题目**: 假设`I`表示入栈，`O`表示出栈。一个由`I`和`O`组成的操作序列，如果能保证对一个空栈进行操作后，栈的状态始终合法（即不会对空栈执行出栈操作）且最终栈也为空，则称该序列为合法序列。判断下列哪些是合法序列？并编写算法进行判定。（武汉大学2002/2000年考题） 

- A. `IOIIOIOO`
    
- B. `IOOIOIIO`
    
- C. `IIIOIOIO`
    
- D. `IIIOOIOO`
    

分析与解答:

一个序列是合法的，必须满足两个条件：

1. 在序列的任何一个位置，`O`（出栈）的累计次数不能超过`I`（入栈）的累计次数。
    
2. 序列结束后，`I`的总次数必须等于`O`的总次数。
    

- **A. `IOIIOIOO`**: 合法。
    
- **B. `IOOIOIIO`**: 非法。在第三个字符`O`处，`O`的累计次数为2，`I`的累计次数为1，非法。
    
- **C. `IIIOIOIO`**: 非法。最终`I`有4个，`O`有4个，但序列不平衡。
    
- **D.`IIIOOIOO`**: 合法。 
    

**判定算法**:

```c
int Judge(char A[]) {
    int i = 0;
    int in_count = 0;  // 记录'I'的个数
    int out_count = 0; // 记录'O'的个数

    while (A[i] != '\0') {
        if (A[i] == 'I') {
            in_count++; 
        } else if (A[i] == 'O') {
            out_count++; 
        }

        // 在任何时候，出栈次数都不能大于入栈次数
        if (out_count > in_count) { 
            return false; // 非法序列
        }

        i++; 
    }

    // 最终，入栈和出栈次数必须相等
    if (in_count != out_count) { 
        return false; // 非法序列
    } else {
        return true; // 合法序列
    }
}
```