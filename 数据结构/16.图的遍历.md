## 一、图的遍历 (Traversing Graph)

### 1. 基本概念

- **定义**: 从图中的某一顶点出发，系统地访问图中的所有顶点，并确保每个顶点只被访问一次。
    
- **与树的遍历区别**: 图可能包含环路，且顶点之间可能存在多条路径。因此，在遍历过程中，可能会沿着某条边回到一个已经被访问过的顶点。
    
- **标记机制**: 为了避免重复访问和无限循环，必须为每个顶点设置一个访问标记。通常使用一个名为 `visited` 的布尔数组：
    
    - 初始状态：所有顶点的 `visited` 标记均为 `false`。
        
    - 访问后：被访问过的顶点的 `visited` 标记置为 `true`。
        

### 2. 主要遍历方法

图的遍历主要有两种经典方法，它们对无向图和有向图都适用：

- **深度优先遍历 (Depth-First Search, DFS)**
    
- **广度优先遍历 (Breadth-First Search, BFS)**
    

## 二、深度优先遍历 (DFS)

DFS类似于树的先序遍历，其核心思想是“一路走到黑”，尽可能深地探索图的分支。

### 1. 算法思想

1. 从图中的某个顶点 `v` 出发，首先访问该顶点。
    
2. 然后，从 `v` 的所有未被访问的邻接点中任选一个 `w`，以 `w` 为起点，递归地进行深度优先遍历。
    
3. 当顶点 `w` 的所有邻接点都被访问过后，回溯到 `v`，继续选择 `v` 的另一个未被访问的邻接点，重复上述过程。
    
4. 直到图中所有与起点 `v` 连通的顶点都被访问到。
    
5. 若图为非连通图，则需对每个连通分量重复以上步骤。
    

### 2. 递归算法实现

```c
// visited数组需在外部初始化为全false
void DFS(Graph g, int v) {
    // 访问当前顶点v
    cout << g.vertex[v] << " "; 
    visited[v] = true; // 设置访问标记

    // 遍历v的所有邻接点w
    int w = FirstAdjVertex(g, v);
    while (w != -1) {
        if (!visited[w]) {
            // 如果w未被访问，则递归调用DFS
            DFS(g, w);
        }
        // 寻找v的下一个邻接点
        w = NextAdjVertex(g, v, w);
    }
}

// 遍历整个图（处理非连通图的情况）
void TraverseGraph(Graph g) {
    for (int v = 0; v < g.vexnum; v++) {
        visited[v] = false;
    }
    for (int v = 0; v < g.vexnum; v++) {
        if (!visited[v]) {
            DFS(g, v);
        }
    }
}
```

### 3. 非递归算法实现

非递归的DFS通常借助一个**栈**来实现。

1. 初始化一个栈，将起始顶点 `v` 压入栈。
    
2. 当栈不为空时，循环执行以下操作：
    
    a. 弹出栈顶顶点 u。
    
    b. 如果 u 未被访问，则访问它，并将其标记为已访问。
    
    c. 查找 u 的所有邻接点，将所有未被访问的邻接点压入栈中。
    

### 4. 复杂度分析

- **时间复杂度**:
    
    - **邻接表**: 访问所有顶点需要 O(n)，查找所有边的邻接点需要 O(e)，总时间复杂度为 O(n+e)。
        
    - **邻接矩阵**: 查找每个顶点的邻接点都需要遍历一行，耗时 O(n)，因此总时间复杂度为 O(n2)。
        
- **空间复杂度**:
    
    - 递归实现：取决于递归深度，最坏情况下为 O(n)。
        
    - 非递归实现：取决于栈的大小，最坏情况下为 O(n)。
        

## 三、广度优先遍历 (BFS)

BFS类似于树的层次遍历，其核心思想是“逐层扩散”，从起点开始，先访问完所有距离为1的邻接点，再访问所有距离为2的邻接点，以此类推。

### 1. 算法思想

BFS通常借助一个**队列**来实现。

1. 从图中的某个顶点 `v` 出发，访问该顶点，并将其入队。
    
2. 当队列不为空时，循环执行以下操作：
    
    a. 队首顶点 u 出队。
    
    b. 依次访问 u 的所有未被访问的邻接点 w。
    
    c. 将这些被访问的邻接点 w 标记为已访问，并让它们依次入队。
    
3. 直到队列为空，完成一次遍历。
    
4. 若图为非连通图，则需对每个连通分量重复以上步骤。
    

### 2. 算法实现

```c
// visited数组需在外部初始化为全false
void BFS(Graph g, int v) {
    cout << g.vertex[v] << " ";
    visited[v] = true;

    InitQueue(Q);       // 初始化队列
    EnterQueue(Q, v);   // 顶点v入队

    while (!IsEmpty(Q)) {
        DeleteQueue(Q, u); // 队首顶点u出队

        // 遍历u的所有邻接点w
        int w = FirstAdjVertex(g, u);
        while (w != -1) {
            if (!visited[w]) {
                // 访问w
                cout << g.vertex[w] << " ";
                visited[w] = true;
                EnterQueue(Q, w); // w入队
            }
            // 寻找u的下一个邻接点
            w = NextAdjVertex(g, u, w);
        }
    }
}
```

### 3. 复杂度分析

- **时间复杂度**: 与DFS相同。
    
    - **邻接表**: O(n+e)。
        
    - **邻接矩阵**: O(n2)。
        
- **空间复杂度**: 取决于队列的大小，最坏情况下为 O(n)。
    

## 四、图的连通性与生成树

### 1. 生成树 (Spanning Tree)

- **定义**: 对于一个连通图 `G`，其生成树是一个包含 `G` 中所有顶点，且边数最少的连通子图。
    
- **性质**:
    
    - 顶点数与原图相同，为 `n`。
        
    - 边数为 `n-1`。
        
    - 是图的**极小连通子图**，即任意去掉一条边都会导致图不连通。
        
    - 在生成树中再任意增加一条边，必然会形成一个环路。
        
    - 树中任意两个顶点之间的路径是唯一的。
        
- **生成方式**: DFS和BFS在遍历过程中经过的边可以分别构成**深度优先生成树**和**广度优先生成树**。
    

### 2. 生成森林 (Spanning Forest)

- 对于非连通图，其每个连通分量的生成树共同构成了该图的**生成森林**。
    

## 五、最小生成树 (Minimum Spanning Tree, MST)

### 1. 定义

- 针对带权的连通无向图。
    
- **最小生成树 (MST)** 是指所有生成树中，各边权值之和最小的那棵生成树。
    
- **应用**: 在n个城市间铺设通信线路、输油管道等，要在保证所有城市连通的前提下，使总成本最低。
    

### 2. Prim (普里姆) 算法

- **思想**: 从一个顶点开始，逐步“扩张”这棵树。每次都选择连接“树内顶点”与“树外顶点”的、权值最小的边，并将其和对应的“树外顶点”纳入树中，直到所有顶点都被包含进来。
    
- **步骤**:
    
    1. 设图 `G=(V, E)`，初始化一个集合 `U`，用于存放已加入MST的顶点，初始时 `U` 中只有一个起始顶点 `u0`。
        
    2. 维护一个 `lowcost` 数组，记录所有“树外顶点” `v` 到集合 `U` 中顶点的最短边的权值。
        
    3. 重复以下操作 n-1 次：
        
        a. 在 lowcost 数组中找到一个权值最小的、且顶点不在 U 中的边 (u, v)。
        
        b. 将顶点 v 加入集合 U。
        
        c. 将边 (u, v) 加入MST。
        
        d. 更新 lowcost 数组：对于所有 v 的邻接点 w，如果 v 到 w 的边的权值小于 lowcost\[w\]，则更新 lowcost\[w\]。
        
- **时间复杂度**: O(n2)，适用于**稠密图**。
    

### 3. Kruskal (克鲁斯卡尔) 算法

- **思想**: 从边的角度出发，每次都选择图中权值最小且不构成环路的边，加入到MST中，直到加入 `n-1` 条边为止。
    
- **步骤**:
    
    1. 将图中的所有 `n` 个顶点视为 `n` 个独立的连通分量（即一个森林）。
        
    2. 将图中所有的 `e` 条边按权值从小到大进行排序。
        
    3. 依次遍历排序后的边 (u, v)：
        
        a. 判断顶点 u 和 v 是否属于同一个连通分量（通常用并查集判断）。
        
        b. 如果不属于同一个连通分量（即加入该边不会形成环路），则将此边加入MST，并合并 u 和 v 所在的连通分量。
        
        c. 如果属于同一个连通分量，则舍弃此边。
        
    4. 重复步骤3，直到MST中有 `n-1` 条边。
        
- **时间复杂度**: $O(e\log e)$，主要取决于对边进行排序的时间。适用于**稀疏图**。