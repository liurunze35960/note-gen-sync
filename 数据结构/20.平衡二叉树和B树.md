## 一、平衡二叉树 (AVL树)

### 1. 定义

- **平衡因子 (Balance Factor, BF)**: 结点的左子树高度减去右子树高度的差值。
    
    $$BF=H_L​−H_R$$ ​
- **平衡二叉树 (AVL Tree)**: 一种自平衡的二叉搜索树。它的任何一个结点的平衡因子都只可能是 `1`, `0` 或 `-1`。也就是说，每个结点的左右子树的高度差最多为1。
    
- **注意**: 完全二叉树一定是平衡二叉树，但平衡二叉树不一定是完全二叉树。
    

### 2. 平衡调整

当向AVL树中插入或删除节点，导致某个结点的平衡因子绝对值大于1时，树的平衡就被破坏了。需要对树进行调整，使其重新恢复平衡。

- **最小不平衡子树**: 在平衡二叉树的构造过程中，以距离插入结点最近、且平衡因子的绝对值大于1的结点为根的子树。调整操作主要针对最小不平衡子树进行。
    
- **基本思想**: 在构造二叉排序树的过程中，每插入一个结点，就检查是否破坏了树的平衡性。如果破坏了，则找到最小不平衡子树，在保持二叉排序树特性的前提下，通过**旋转**操作调整该子树中各结点之间的链接关系，使其成为新的平衡子树。
    

### 3. 平衡化旋转

设A为最小不平衡子树的根结点，根据新插入结点的位置，调整分为四种情况：

1. **LL型**: 新结点插入在A的**左**子树的**左**子树上。
    
    - **调整策略**: 对A进行**单次右旋**。
        
2. **RR型**: 新结点插入在A的**右**子树的**右**子树上。
    
    - **调整策略**: 对A进行**单次左旋**。
        
3. **LR型**: 新结点插入在A的**左**子树的**右**子树上。
    
    - **调整策略**: 先对A的左孩子进行**左旋**，然后对A进行**右旋**（双旋转）。
        
4. **RL型**: 新结点插入在A的**右**子树的**左**子树上。
    
    - **调整策略**: 先对A的右孩子进行**右旋**，然后对A进行**左旋**（双旋转）。
        

### 4. AVL树查找性能分析

- 在平衡树上进行查找时，与给定值进行比较的关键字数量不会超过树的深度。
    
- 由于AVL树的高度保持在对数级别，其查找、插入和删除操作的平均和最坏时间复杂度均为：
    
    $$O(logn)$$

## 二、B树

### 1. 为什么需要B树

B树（或称B-树）是一种为磁盘或其他直接存取辅助设备而设计的多路平衡查找树。在数据库和文件系统中，由于I/O操作（访问磁盘）远慢于内存操作，B树通过减少访问磁盘的次数来提高性能。它的特点是结点可以拥有多个孩子，从而降低树的高度。

### 2. B树的定义 (m阶)

一棵m阶的B树满足以下性质：

- **多路性**: 每个非叶子结点最多有 `m` 个孩子。
    
- **关键字有序**: 非叶子结点内的关键字自小到大排列：K1​<K2​<...<Kn​。
    
- **子树关键字范围**:
    
    - 指针 Ai−1​ 所指子树上的所有关键字都小于 Ki​。
        
    - 指针 Ai​ 所指子树上的所有关键字都大于 Ki​。
        
- **平衡性**:
    
    - 所有叶子结点都位于同一层。
        
    - 根结点若不是叶子，则至少有两个孩子。
        
    - 除根结点外的所有非叶子结点至少有 ⌈m/2⌉ 个孩子（即至少有 ⌈m/2⌉−1 个关键字）。
        

### 3. B树的查找

查找过程从根结点开始，在结点内部使用二分查找或顺序查找来定位关键字。

1. 在当前结点中查找关键字。
    
2. 如果找到，则查找成功。
    
3. 如果未找到，则根据要查找的关键字与结点内关键字的比较结果，进入相应的子树继续查找。
    
4. 重复上述过程，直到找到关键字或查找到空的子树指针（查找失败）。
    

### 4. B树的插入

1. 首先执行查找操作，确定新关键字的插入位置（必定在最底层的非叶子结点）。
    
2. **情况一：结点未满**: 如果目标结点的关键字数量 `n < m-1`，直接将新关键字插入到该结点的正确位置。
    
3. 情况二：结点已满: 如果目标结点的关键字数量 n = m-1，插入后会导致结点溢出。此时需要进行结点分裂：
    
    a. 以结点的中间关键字 K⌈m/2⌉​ 为界，将结点分裂成两个新结点。
    
    b. 原结点保留前 ⌈m/2⌉−1 个关键字。
    
    c. 新创建的结点包含后 m−⌈m/2⌉ 个关键字。
    
    d. 将中间关键字 K⌈m/2⌉​ 提升到父结点中。
    
    e. 如果父结点也因此溢出，则对父结点重复分裂过程，直到操作完成或根结点被分裂（此时树的高度增加1）。
    

### 5. B树的删除

1. 首先找到包含待删除关键字的结点。
    
2. **情况一：待删除关键字在非叶子结点**: 用其右子树中的最小关键字（或左子树中的最大关键字）替换它，然后转化为删除那个替换的关键字（该关键字一定在叶子结点）。
    
3. 情况二：待删除关键字在叶子结点:
    
    a. 兄弟结点富余: 如果删除后，当前结点的关键字数量少于 ⌈m/2⌉−1，但其相邻的兄弟结点关键字数量大于 ⌈m/2⌉−1，则可以从兄弟结点“借”一个关键字。这个过程需要通过父结点进行调整，以维持B树的性质。
    
    b. 兄弟结点不富余: 如果相邻的兄弟结点也只有最少的关键字，无法出借，则需要进行结点合并。将当前结点、其相邻兄弟结点以及父结点中分隔这两个兄弟的关键字合并成一个新结点。这个操作可能会导致父结点的关键字数量减少，可能需要递归地向上进行合并，最坏情况下会导致树的高度减1。
    

### 6. B树的性能分析

B树的查找性能主要取决于其深度（高度）H，因为这决定了磁盘I/O的次数。对于一个包含N个关键字的m阶B树，其最大深度H满足：

$$H≤log⌈m/2⌉​2N+1​+1$$

这个公式表明B树的高度非常低，即使在数据量极大的情况下，也能保证高效的查找性能。一次查找需要访问的结点个数不超过 $$log⌈m/2⌉​((N+1)/2)+1$$。