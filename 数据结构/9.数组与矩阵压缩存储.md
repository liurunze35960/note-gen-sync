## 一、数组的定义 (Array)

### 1. 从线性结构到数组

- **线性数据结构**：之前学习的数据结构（如线性表、栈、队列）都是线性结构，其中数据元素被视为不可再分的**原子数据**。
    
- **数组与广义表**：
    
    1. **逻辑结构**：可以看作是线性结构的一种**扩展**。
        
    2. **数据元素**：其数据元素本身也可以是一个数据结构。
        

### 2. 多维数组的理解

- **一维数组**：`a[0], a[1], ..., a[n-1]`，其本身就是一个线性结构。
    
- **二维数组**：可以从两个角度理解：
    
    1. **列向量的线性表**：一个 $m\times n$ 的矩阵 $A_{m\times n}$ 可以看作是 n 个列向量组成的线性表。每个列向量 $\alpha_j=(a_{0j},a_{1j},...,a_{m−1,j})$ 是一个数据元素。
        
    2. **行向量的线性表**：同样，也可以看作是 m 个行向量组成的线性表。每个行向量 $\beta_i=(a_{i0},a_{i1},...,a_{i,n−1})$ 是一个数据元素。
        
- **n维数组**：
    
    - 是线性表的推广，可以看作是数据元素为 (n-1)维数组的线性表。
        
    - 数组中的每个元素 $a_{j_1,j_2,...,j_n}$ 由一组唯一的下标 ($j_1,j_2,...,j_n$) 确定。
        
    - 除边界元素外，每个元素在每一维上都有一个直接前驱和一个直接后继。
        

### 3. 数组的结构特性

1. **固定性**：数组的维数和每一维的界限一旦定义，其元素的总数就固定了。
    
2. **基本操作**：对数组的操作通常只有两种：
    
    - **存取 (Access)**：获取特定位置的元素值。
        
    - **修改 (Update)**：修改特定位置的元素值。
        

## 二、数组的顺序表示

计算机的物理内存是一维线性的，因此需要将多维的逻辑结构通过某种次序映射到一维内存中。

### 1. 数组的存储方式

- **行优先存储 (Row-Major Order)**：将数组元素按行依次存入内存。这是C/C++/Java/Python等多数高级语言采用的方式。
    
- **列优先存储 (Column-Major Order)**：将数组元素按列依次存入内存。Fortran是采用这种方式的典型代表。
    

### 2. 地址计算公式

假设数组元素占用 `L` 个存储单元，数组的基地址（第一个元素的地址）为Loc($a_{00...0}$)。

- **二维数组** $A_{m\times n}$ **(按行优先)**
    
    - 元素 $a_{ij}$ 的地址为：
        
        Loc($a_{ij}$​)=Loc($a_{00}$​)+(i×n+j)×L
- **三维数组** $A_{b_1\times{b_2}\times{b_3}}$ **(按页/行/列存放)**
    
    - 元素 $a_{i_1,i_2,i_3}$ 的地址为：
        
        Loc($a_{i1​,i2​,i3}$​​)=Loc($a_{000}$​)+(i1​×b2​×b3​+i2​×b3​+i3​)×L
- **n维数组** $A_{b_1 \times b_2\times ...\times b_n}$ **(按行优先)**
    
    - 元素 $a_{i_1,i_2,...,i_n}$ 的地址为：
        
	    $\text{LOC}(i_1, i_2, \dots, i_n) = \text{LOC}(a_{00000\dots 00}) + \left ( \sum_{k=1}^{n} \left ( i_k \prod_{j=k+1}^{n} b_j \right) \right) \cdot L$
- **下标不从0开始的通用情况**
    
    - 对于二维数组 A\[$c_1: d_1,c_2: d_2$\]，每行有 $n=d_2−c_2+1$ 个元素。
        
    - 按行存放时，元素 $a_{ij}$ 的地址为：
        
        Loc(aij​)=Loc(ac1​,c2​​)+((i−c1​)×n+(j−c2​))×L

## 三、矩阵的压缩存储

在科学与工程计算中，常出现一些高阶的特殊矩阵或稀疏矩阵。为了节省宝贵的存储空间，需要对这类矩阵进行**压缩存储**。

**核心思想**：

- 为多个值相同的元素只分配一个存储空间。
    
- 对零元素不分配存储空间。
    

### 1. 特殊矩阵

值相同的元素或零元素分布有规律的矩阵。

#### a) 对称矩阵 (Symmetric Matrix)

- **特点**：对于n阶方阵A，所有元素满足 $a_{ij}=a_{ji}$。
    
- **压缩策略**：只需存储主对角线及下三角区（或上三角区）的元素。
    
- **存储方式**：将下三角区的元素（包括主对角线）按行优先存入一维数组 `elems`所需空间为 $\frac{n(n+1)}{2}$。
    
- **地址映射**：对于元素 $a_{ij}$，其在一维数组 `elems` 中的下标 `k` 为：
    
    - 当 $i\ge j$ (下三角区及对角线) 时：
        
        $k=\frac{i(i−1)​}{2}+j-1$ 
        
        (注：此处假设数组下标从0开始，矩阵下标i, j从1开始。若矩阵下标从0开始，则为 $k=\frac {i(i+1)}{2}+j-1$
        
    - 当 i\<j (上三角区) 时，利用对称性 $a_{ij}=a_{ji}$，查找 $a_{ji}$ 的位置。
        

#### b) 三角矩阵 (Triangular Matrix)

- **特点**：上三角或下三角区域的元素均为同一个常量 `c`（或0）。
    
- **压缩策略**：存储对角线和非公共常量区的元素，再加上一个空间存储常量 `c`。
    
- **存储方式**：将非公共常量区的元素和对角线元素按行优先存入一维数组 `elems`，并将常量 `c` 存放在数组的末尾或开头。所需空间为 $\frac{n(n+1)}{2}+1$。
    
- **地址映射**（以下三角矩阵为例）：
    
    - 当 $i\ge j$ (下三角区及对角线) 时，其在 `elems` 中的位置为：
        
        $k=\frac{{i(i−1)}}{2}​+j$ (常量 `c` 占据了 `k=0`)
    - 当 $i\lt j$ (上三角区) 时，其值为常量 `c`。

#### c) 对角矩阵 (Diagonal Matrix) / 带状矩阵 (Band Matrix)

- **特点**：所有非零元素都集中在以主对角线为中心的带状区域内。例如，**三对角矩阵**，非零元素仅分布在主对角线 (i=j)、低对角线 (i=j+1) 和高对角线 (i=j−1) 上。
    
- **压缩策略**：只存储带状区域内的元素。
    
- **存储方式**：将所有非零元素按行优先存入一维数组 `elems`。对于三对角矩阵，所需空间为 3n−2。（可能有常数 `C`）
    
- **地址映射**（以三对角矩阵为例）：
    
    - 对于元素 $a_{ij}$，其在一维数组 `elems` 中的下标 `k` 为：
        
        - 前 i−1 行共有 $3(i−1)−1$ 个非零元素（第一行只有2个）。
            
        - 第 i 行中 $a_{ij}$ 是第 $j−i+2$ 个非零元素。
            
        - 因此，$k=(3(i−1)−1)+(j−i+2)=2i+j−2$。
            

### 2. 稀疏矩阵 (Sparse Matrix)

- **特点**：矩阵中非零元素的个数远小于零元素的个数，且分布没有明显规律。
    
- **稀疏因子**：$\delta=\frac t {m \times n}$ (t为非零元个数)。通常认为 $\delta \le0.05$ 的矩阵为稀疏矩阵。
    

#### a) 三元组顺序表 (Triple)

- **思想**：*只存储非零元素*。每个非零元素用一个**三元组 (行号, 列号, 值)** 来表示。
    
- **存储结构**：
    
    ```c
    #define MAXSIZE 1000
    typedef struct {
        int row, col; // 非零元素的行、列下标
        ElemType e;   // 非零元素的值
    } Triple;
    
    typedef struct {
        Triple data[MAXSIZE+1]; // 三元组数组
        int m, n, len;        // 矩阵的行数、列数和非零元个数
    } TSMatrix;
    ```
    
- **优点**：存储空间大大减少，空间复杂度为 O($len$)。
    
- **缺点**：失去了随机存取的能力，查找元素需要遍历三元组表。
    

#### b) 稀疏矩阵的转置

将一个 $m\times n$ 的矩阵 M 转置为 $n\times m$ 的矩阵 T。

- **普通转置算法**：
    
    1. 交换矩阵的行数和列数。
        
    2. 遍历原三元组表 `source`，将每个三元组的 `row` 和 `col` 互换，存入新的三元组表 `dest`。
        
    3. 对 `dest` 表按照新的行号（原列号）、列号（原行号）进行排序。
        
    
    - **改进（按列序转置）**：直接遍历 `source` 的所有列，找到属于该列的所有元素，交换行列后放入 `dest`。这样 `dest` 自然有序。
        
    - **时间复杂度**：O($n \times len$)。当矩阵不稀疏时，接近 O($m \times n^2$)，效率较低。
        
- **快速转置算法**：
    
    - **核心思想**：一次遍历 `source` 表，就将每个三元组元素直接放到它在 `dest` 表中的最终正确位置，避免了排序或多次遍历。
        
    - **实现步骤**：
        
        1. **设置辅助数组**：
            
            - `num[col]`：统计原矩阵 `source` 中第 `col` 列有多少个非零元素。
                
            - `position[col]`：存放原矩阵 `source` 中第 `col` 列的**第一个**非零元素，在转置后的 `dest` 表中应该存放的位置。
                
        2. **计算 `num` 数组**：遍历 `source` 表一次，根据每个元素的 `col` 值，对相应的 `num[col]` 加一。
            
        3. **计算 `position` 数组**：根据 `num` 数组计算。
            
            - `position[1] = 1` (假设下标从1开始)
                
            - `position[col] = position[col-1] + num[col-1]`
                
        4. **执行转置**：再次遍历 `source` 表，对于每个元素 `source[p]`：
            
            - 获取其列号 `col = source[p].col`。
                
            - 从 `position[col]` 获得它在 `dest` 中的位置 `q`。
                
            - 将转置后的三元组放入 `dest[q]`。
                
            - 将 `position[col]` 的值加一，为该列的下一个元素准备位置。
                
    - **时间复杂度**：O(n+len)。线性时间复杂度，效率高。
        
    - **空间复杂度**：O(n+len)。用两个辅助数组（大小为n）换取了时间效率的提升。
        

#### c) 十字链表 (Cross-Linked List)

- **思想**：当矩阵运算（如矩阵加法）会改变非零元个数时，**顺序存储**的三元组不便于插入和删除。十字链表提供了链式存储方案。
    
- **结点结构**：每个非零元是一个结点，包含：
    
    - `row`, `col`, `value`：三元组信息。
        
    - `right` 指针：指向同一行中的下一个非零元结点。
        
    - `down` 指针：指向同一列中的下一个非零元结点。
        
- **整体结构**：
    
    - 包含一个行头指针数组和一个列头指针数组，分别作为每一行和每一列链表的头结点。
        
    - 整个矩阵形成了一个“十字交叉”的链表网络。
        
- **优点**：方便地进行插入和删除操作，灵活地处理非零元个数变化的情况。